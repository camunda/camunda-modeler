"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkcamunda_modeler_client"] = self["webpackChunkcamunda_modeler_client"] || []).push([["vendors-node_modules_min-dom_dist_index_esm_js-node_modules_preact_hooks_dist_hooks_module_js-48d3c9"],{

/***/ "../node_modules/didi/dist/index.js":
/*!******************************************!*\
  !*** ../node_modules/didi/dist/index.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Injector: () => (/* binding */ Injector),\n/* harmony export */   annotate: () => (/* binding */ annotate),\n/* harmony export */   parseAnnotations: () => (/* binding */ parseAnnotations)\n/* harmony export */ });\nconst CLASS_PATTERN = /^class[ {]/;\n\n\n/**\n * @param {function} fn\n *\n * @return {boolean}\n */\nfunction isClass(fn) {\n  return CLASS_PATTERN.test(fn.toString());\n}\n\n/**\n * @param {any} obj\n *\n * @return {boolean}\n */\nfunction isArray(obj) {\n  return Array.isArray(obj);\n}\n\n/**\n * @param {any} obj\n * @param {string} prop\n *\n * @return {boolean}\n */\nfunction hasOwnProp(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n/**\n * @typedef {import('./index.js').InjectAnnotated } InjectAnnotated\n */\n\n/**\n * @template T\n *\n * @params {[...string[], T] | ...string[], T} args\n *\n * @return {T & InjectAnnotated}\n */\nfunction annotate(...args) {\n\n  if (args.length === 1 && isArray(args[0])) {\n    args = args[0];\n  }\n\n  args = [ ...args ];\n\n  const fn = args.pop();\n\n  fn.$inject = args;\n\n  return fn;\n}\n\n\n// Current limitations:\n// - can't put into \"function arg\" comments\n// function /* (no parenthesis like this) */ (){}\n// function abc( /* xx (no parenthesis like this) */ a, b) {}\n//\n// Just put the comment before function or inside:\n// /* (((this is fine))) */ function(a, b) {}\n// function abc(a) { /* (((this is fine))) */}\n//\n// - can't reliably auto-annotate constructor; we'll match the\n// first constructor(...) pattern found which may be the one\n// of a nested class, too.\n\nconst CONSTRUCTOR_ARGS = /constructor\\s*[^(]*\\(\\s*([^)]*)\\)/m;\nconst FN_ARGS = /^(?:async\\s+)?(?:function\\s*[^(]*)?(?:\\(\\s*([^)]*)\\)|(\\w+))/m;\nconst FN_ARG = /\\/\\*([^*]*)\\*\\//m;\n\n/**\n * @param {unknown} fn\n *\n * @return {string[]}\n */\nfunction parseAnnotations(fn) {\n\n  if (typeof fn !== 'function') {\n    throw new Error(`Cannot annotate \"${fn}\". Expected a function!`);\n  }\n\n  const match = fn.toString().match(isClass(fn) ? CONSTRUCTOR_ARGS : FN_ARGS);\n\n  // may parse class without constructor\n  if (!match) {\n    return [];\n  }\n\n  const args = match[1] || match[2];\n\n  return args && args.split(',').map(arg => {\n    const argMatch = arg.match(FN_ARG);\n    return (argMatch && argMatch[1] || arg).trim();\n  }) || [];\n}\n\n/**\n * @typedef { import('./index.js').ModuleDeclaration } ModuleDeclaration\n * @typedef { import('./index.js').ModuleDefinition } ModuleDefinition\n * @typedef { import('./index.js').InjectorContext } InjectorContext\n *\n * @typedef { import('./index.js').TypedDeclaration<any, any> } TypedDeclaration\n */\n\n/**\n * Create a new injector with the given modules.\n *\n * @param {ModuleDefinition[]} modules\n * @param {InjectorContext} [_parent]\n */\nfunction Injector(modules, _parent) {\n\n  const parent = _parent || /** @type InjectorContext */ ({\n    get: function(name, strict) {\n      currentlyResolving.push(name);\n\n      if (strict === false) {\n        return null;\n      } else {\n        throw error(`No provider for \"${ name }\"!`);\n      }\n    }\n  });\n\n  const currentlyResolving = [];\n  const providers = this._providers = Object.create(parent._providers || null);\n  const instances = this._instances = Object.create(null);\n\n  const self = instances.injector = this;\n\n  const error = function(msg) {\n    const stack = currentlyResolving.join(' -> ');\n    currentlyResolving.length = 0;\n    return new Error(stack ? `${ msg } (Resolving: ${ stack })` : msg);\n  };\n\n  /**\n   * Return a named service.\n   *\n   * @param {string} name\n   * @param {boolean} [strict=true] if false, resolve missing services to null\n   *\n   * @return {any}\n   */\n  function get(name, strict) {\n    if (!providers[name] && name.includes('.')) {\n\n      const parts = name.split('.');\n      let pivot = get(/** @type { string } */ (parts.shift()));\n\n      while (parts.length) {\n        pivot = pivot[/** @type { string } */ (parts.shift())];\n      }\n\n      return pivot;\n    }\n\n    if (hasOwnProp(instances, name)) {\n      return instances[name];\n    }\n\n    if (hasOwnProp(providers, name)) {\n      if (currentlyResolving.indexOf(name) !== -1) {\n        currentlyResolving.push(name);\n        throw error('Cannot resolve circular dependency!');\n      }\n\n      currentlyResolving.push(name);\n      instances[name] = providers[name][0](providers[name][1]);\n      currentlyResolving.pop();\n\n      return instances[name];\n    }\n\n    return parent.get(name, strict);\n  }\n\n  function fnDef(fn, locals) {\n\n    if (typeof locals === 'undefined') {\n      locals = {};\n    }\n\n    if (typeof fn !== 'function') {\n      if (isArray(fn)) {\n        fn = annotate(fn.slice());\n      } else {\n        throw error(`Cannot invoke \"${ fn }\". Expected a function!`);\n      }\n    }\n\n    /**\n     * @type {string[]}\n     */\n    const inject = fn.$inject || parseAnnotations(fn);\n    const dependencies = inject.map(dep => {\n      if (hasOwnProp(locals, dep)) {\n        return locals[dep];\n      } else {\n        return get(dep);\n      }\n    });\n\n    return {\n      fn: fn,\n      dependencies\n    };\n  }\n\n  /**\n   * Instantiate the given type, injecting dependencies.\n   *\n   * @template T\n   *\n   * @param { Function | [...string[], Function ]} type\n   *\n   * @return T\n   */\n  function instantiate(type) {\n    const {\n      fn,\n      dependencies\n    } = fnDef(type);\n\n    // instantiate var args constructor\n    const Constructor = Function.prototype.bind.call(fn, null, ...dependencies);\n\n    return new Constructor();\n  }\n\n  /**\n   * Invoke the given function, injecting dependencies. Return the result.\n   *\n   * @template T\n   *\n   * @param { Function | [...string[], Function ]} func\n   * @param { Object } [context]\n   * @param { Object } [locals]\n   *\n   * @return {T} invocation result\n   */\n  function invoke(func, context, locals) {\n    const {\n      fn,\n      dependencies\n    } = fnDef(func, locals);\n\n    return fn.apply(context, dependencies);\n  }\n\n  /**\n   * @param {Injector} childInjector\n   *\n   * @return {Function}\n   */\n  function createPrivateInjectorFactory(childInjector) {\n    return annotate(key => childInjector.get(key));\n  }\n\n  /**\n   * @param {ModuleDefinition[]} modules\n   * @param {string[]} [forceNewInstances]\n   *\n   * @return {Injector}\n   */\n  function createChild(modules, forceNewInstances) {\n    if (forceNewInstances && forceNewInstances.length) {\n      const fromParentModule = Object.create(null);\n      const matchedScopes = Object.create(null);\n\n      const privateInjectorsCache = [];\n      const privateChildInjectors = [];\n      const privateChildFactories = [];\n\n      let provider;\n      let cacheIdx;\n      let privateChildInjector;\n      let privateChildInjectorFactory;\n\n      for (let name in providers) {\n        provider = providers[name];\n\n        if (forceNewInstances.indexOf(name) !== -1) {\n          if (provider[2] === 'private') {\n            cacheIdx = privateInjectorsCache.indexOf(provider[3]);\n            if (cacheIdx === -1) {\n              privateChildInjector = provider[3].createChild([], forceNewInstances);\n              privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);\n              privateInjectorsCache.push(provider[3]);\n              privateChildInjectors.push(privateChildInjector);\n              privateChildFactories.push(privateChildInjectorFactory);\n              fromParentModule[name] = [ privateChildInjectorFactory, name, 'private', privateChildInjector ];\n            } else {\n              fromParentModule[name] = [ privateChildFactories[cacheIdx], name, 'private', privateChildInjectors[cacheIdx] ];\n            }\n          } else {\n            fromParentModule[name] = [ provider[2], provider[1] ];\n          }\n          matchedScopes[name] = true;\n        }\n\n        if ((provider[2] === 'factory' || provider[2] === 'type') && provider[1].$scope) {\n          /* jshint -W083 */\n          forceNewInstances.forEach(scope => {\n            if (provider[1].$scope.indexOf(scope) !== -1) {\n              fromParentModule[name] = [ provider[2], provider[1] ];\n              matchedScopes[scope] = true;\n            }\n          });\n        }\n      }\n\n      forceNewInstances.forEach(scope => {\n        if (!matchedScopes[scope]) {\n          throw new Error('No provider for \"' + scope + '\". Cannot use provider from the parent!');\n        }\n      });\n\n      modules.unshift(fromParentModule);\n    }\n\n    return new Injector(modules, self);\n  }\n\n  const factoryMap = {\n    factory: invoke,\n    type: instantiate,\n    value: function(value) {\n      return value;\n    }\n  };\n\n  /**\n   * @param {ModuleDefinition} moduleDefinition\n   * @param {Injector} injector\n   */\n  function createInitializer(moduleDefinition, injector) {\n\n    const initializers = moduleDefinition.__init__ || [];\n\n    return function() {\n      initializers.forEach(initializer => {\n\n        // eagerly resolve component (fn or string)\n        if (typeof initializer === 'string') {\n          injector.get(initializer);\n        } else {\n          injector.invoke(initializer);\n        }\n      });\n    };\n  }\n\n  /**\n   * @param {ModuleDefinition} moduleDefinition\n   */\n  function loadModule(moduleDefinition) {\n\n    const moduleExports = moduleDefinition.__exports__;\n\n    // private module\n    if (moduleExports) {\n      const nestedModules = moduleDefinition.__modules__;\n\n      const clonedModule = Object.keys(moduleDefinition).reduce((clonedModule, key) => {\n\n        if (key !== '__exports__' && key !== '__modules__' && key !== '__init__' && key !== '__depends__') {\n          clonedModule[key] = moduleDefinition[key];\n        }\n\n        return clonedModule;\n      }, Object.create(null));\n\n      const childModules = (nestedModules || []).concat(clonedModule);\n\n      const privateInjector = createChild(childModules);\n      const getFromPrivateInjector = annotate(function(key) {\n        return privateInjector.get(key);\n      });\n\n      moduleExports.forEach(function(key) {\n        providers[key] = [ getFromPrivateInjector, key, 'private', privateInjector ];\n      });\n\n      // ensure child injector initializes\n      const initializers = (moduleDefinition.__init__ || []).slice();\n\n      initializers.unshift(function() {\n        privateInjector.init();\n      });\n\n      moduleDefinition = Object.assign({}, moduleDefinition, {\n        __init__: initializers\n      });\n\n      return createInitializer(moduleDefinition, privateInjector);\n    }\n\n    // normal module\n    Object.keys(moduleDefinition).forEach(function(key) {\n\n      if (key === '__init__' || key === '__depends__') {\n        return;\n      }\n\n      const typeDeclaration = /** @type { TypedDeclaration } */ (\n        moduleDefinition[key]\n      );\n\n      if (typeDeclaration[2] === 'private') {\n        providers[key] = typeDeclaration;\n        return;\n      }\n\n      const type = typeDeclaration[0];\n      const value = typeDeclaration[1];\n\n      providers[key] = [ factoryMap[type], arrayUnwrap(type, value), type ];\n    });\n\n    return createInitializer(moduleDefinition, self);\n  }\n\n  /**\n   * @param {ModuleDefinition[]} moduleDefinitions\n   * @param {ModuleDefinition} moduleDefinition\n   *\n   * @return {ModuleDefinition[]}\n   */\n  function resolveDependencies(moduleDefinitions, moduleDefinition) {\n\n    if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {\n      return moduleDefinitions;\n    }\n\n    moduleDefinitions = (moduleDefinition.__depends__ || []).reduce(resolveDependencies, moduleDefinitions);\n\n    if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {\n      return moduleDefinitions;\n    }\n\n    return moduleDefinitions.concat(moduleDefinition);\n  }\n\n  /**\n   * @param {ModuleDefinition[]} moduleDefinitions\n   *\n   * @return { () => void } initializerFn\n   */\n  function bootstrap(moduleDefinitions) {\n\n    const initializers = moduleDefinitions\n      .reduce(resolveDependencies, [])\n      .map(loadModule);\n\n    let initialized = false;\n\n    return function() {\n\n      if (initialized) {\n        return;\n      }\n\n      initialized = true;\n\n      initializers.forEach(initializer => initializer());\n    };\n  }\n\n  // public API\n  this.get = get;\n  this.invoke = invoke;\n  this.instantiate = instantiate;\n  this.createChild = createChild;\n\n  // setup\n  this.init = bootstrap(modules);\n}\n\n\n// helpers ///////////////\n\nfunction arrayUnwrap(type, value) {\n  if (type !== 'value' && isArray(value)) {\n    value = annotate(value.slice());\n  }\n\n  return value;\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRWdEO0FBQ2hEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2FtdW5kYS1tb2RlbGVyLWNsaWVudC8uLi9ub2RlX21vZHVsZXMvZGlkaS9kaXN0L2luZGV4LmpzPzBkNDUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQ0xBU1NfUEFUVEVSTiA9IC9eY2xhc3NbIHtdLztcblxuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNDbGFzcyhmbikge1xuICByZXR1cm4gQ0xBU1NfUEFUVEVSTi50ZXN0KGZuLnRvU3RyaW5nKCkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBvYmpcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBvYmpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaGFzT3duUHJvcChvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vaW5kZXguanMnKS5JbmplY3RBbm5vdGF0ZWQgfSBJbmplY3RBbm5vdGF0ZWRcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKlxuICogQHBhcmFtcyB7Wy4uLnN0cmluZ1tdLCBUXSB8IC4uLnN0cmluZ1tdLCBUfSBhcmdzXG4gKlxuICogQHJldHVybiB7VCAmIEluamVjdEFubm90YXRlZH1cbiAqL1xuZnVuY3Rpb24gYW5ub3RhdGUoLi4uYXJncykge1xuXG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgYXJncyA9IGFyZ3NbMF07XG4gIH1cblxuICBhcmdzID0gWyAuLi5hcmdzIF07XG5cbiAgY29uc3QgZm4gPSBhcmdzLnBvcCgpO1xuXG4gIGZuLiRpbmplY3QgPSBhcmdzO1xuXG4gIHJldHVybiBmbjtcbn1cblxuXG4vLyBDdXJyZW50IGxpbWl0YXRpb25zOlxuLy8gLSBjYW4ndCBwdXQgaW50byBcImZ1bmN0aW9uIGFyZ1wiIGNvbW1lbnRzXG4vLyBmdW5jdGlvbiAvKiAobm8gcGFyZW50aGVzaXMgbGlrZSB0aGlzKSAqLyAoKXt9XG4vLyBmdW5jdGlvbiBhYmMoIC8qIHh4IChubyBwYXJlbnRoZXNpcyBsaWtlIHRoaXMpICovIGEsIGIpIHt9XG4vL1xuLy8gSnVzdCBwdXQgdGhlIGNvbW1lbnQgYmVmb3JlIGZ1bmN0aW9uIG9yIGluc2lkZTpcbi8vIC8qICgoKHRoaXMgaXMgZmluZSkpKSAqLyBmdW5jdGlvbihhLCBiKSB7fVxuLy8gZnVuY3Rpb24gYWJjKGEpIHsgLyogKCgodGhpcyBpcyBmaW5lKSkpICovfVxuLy9cbi8vIC0gY2FuJ3QgcmVsaWFibHkgYXV0by1hbm5vdGF0ZSBjb25zdHJ1Y3Rvcjsgd2UnbGwgbWF0Y2ggdGhlXG4vLyBmaXJzdCBjb25zdHJ1Y3RvciguLi4pIHBhdHRlcm4gZm91bmQgd2hpY2ggbWF5IGJlIHRoZSBvbmVcbi8vIG9mIGEgbmVzdGVkIGNsYXNzLCB0b28uXG5cbmNvbnN0IENPTlNUUlVDVE9SX0FSR1MgPSAvY29uc3RydWN0b3JcXHMqW14oXSpcXChcXHMqKFteKV0qKVxcKS9tO1xuY29uc3QgRk5fQVJHUyA9IC9eKD86YXN5bmNcXHMrKT8oPzpmdW5jdGlvblxccypbXihdKik/KD86XFwoXFxzKihbXildKilcXCl8KFxcdyspKS9tO1xuY29uc3QgRk5fQVJHID0gL1xcL1xcKihbXipdKilcXCpcXC8vbTtcblxuLyoqXG4gKiBAcGFyYW0ge3Vua25vd259IGZuXG4gKlxuICogQHJldHVybiB7c3RyaW5nW119XG4gKi9cbmZ1bmN0aW9uIHBhcnNlQW5ub3RhdGlvbnMoZm4pIHtcblxuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgYW5ub3RhdGUgXCIke2ZufVwiLiBFeHBlY3RlZCBhIGZ1bmN0aW9uIWApO1xuICB9XG5cbiAgY29uc3QgbWF0Y2ggPSBmbi50b1N0cmluZygpLm1hdGNoKGlzQ2xhc3MoZm4pID8gQ09OU1RSVUNUT1JfQVJHUyA6IEZOX0FSR1MpO1xuXG4gIC8vIG1heSBwYXJzZSBjbGFzcyB3aXRob3V0IGNvbnN0cnVjdG9yXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBhcmdzID0gbWF0Y2hbMV0gfHwgbWF0Y2hbMl07XG5cbiAgcmV0dXJuIGFyZ3MgJiYgYXJncy5zcGxpdCgnLCcpLm1hcChhcmcgPT4ge1xuICAgIGNvbnN0IGFyZ01hdGNoID0gYXJnLm1hdGNoKEZOX0FSRyk7XG4gICAgcmV0dXJuIChhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXSB8fCBhcmcpLnRyaW0oKTtcbiAgfSkgfHwgW107XG59XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vaW5kZXguanMnKS5Nb2R1bGVEZWNsYXJhdGlvbiB9IE1vZHVsZURlY2xhcmF0aW9uXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9pbmRleC5qcycpLk1vZHVsZURlZmluaXRpb24gfSBNb2R1bGVEZWZpbml0aW9uXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9pbmRleC5qcycpLkluamVjdG9yQ29udGV4dCB9IEluamVjdG9yQ29udGV4dFxuICpcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2luZGV4LmpzJykuVHlwZWREZWNsYXJhdGlvbjxhbnksIGFueT4gfSBUeXBlZERlY2xhcmF0aW9uXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5qZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gbW9kdWxlcy5cbiAqXG4gKiBAcGFyYW0ge01vZHVsZURlZmluaXRpb25bXX0gbW9kdWxlc1xuICogQHBhcmFtIHtJbmplY3RvckNvbnRleHR9IFtfcGFyZW50XVxuICovXG5mdW5jdGlvbiBJbmplY3Rvcihtb2R1bGVzLCBfcGFyZW50KSB7XG5cbiAgY29uc3QgcGFyZW50ID0gX3BhcmVudCB8fCAvKiogQHR5cGUgSW5qZWN0b3JDb250ZXh0ICovICh7XG4gICAgZ2V0OiBmdW5jdGlvbihuYW1lLCBzdHJpY3QpIHtcbiAgICAgIGN1cnJlbnRseVJlc29sdmluZy5wdXNoKG5hbWUpO1xuXG4gICAgICBpZiAoc3RyaWN0ID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycm9yKGBObyBwcm92aWRlciBmb3IgXCIkeyBuYW1lIH1cIiFgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IGN1cnJlbnRseVJlc29sdmluZyA9IFtdO1xuICBjb25zdCBwcm92aWRlcnMgPSB0aGlzLl9wcm92aWRlcnMgPSBPYmplY3QuY3JlYXRlKHBhcmVudC5fcHJvdmlkZXJzIHx8IG51bGwpO1xuICBjb25zdCBpbnN0YW5jZXMgPSB0aGlzLl9pbnN0YW5jZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGNvbnN0IHNlbGYgPSBpbnN0YW5jZXMuaW5qZWN0b3IgPSB0aGlzO1xuXG4gIGNvbnN0IGVycm9yID0gZnVuY3Rpb24obXNnKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBjdXJyZW50bHlSZXNvbHZpbmcuam9pbignIC0+ICcpO1xuICAgIGN1cnJlbnRseVJlc29sdmluZy5sZW5ndGggPSAwO1xuICAgIHJldHVybiBuZXcgRXJyb3Ioc3RhY2sgPyBgJHsgbXNnIH0gKFJlc29sdmluZzogJHsgc3RhY2sgfSlgIDogbXNnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIGEgbmFtZWQgc2VydmljZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtib29sZWFufSBbc3RyaWN0PXRydWVdIGlmIGZhbHNlLCByZXNvbHZlIG1pc3Npbmcgc2VydmljZXMgdG8gbnVsbFxuICAgKlxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICBmdW5jdGlvbiBnZXQobmFtZSwgc3RyaWN0KSB7XG4gICAgaWYgKCFwcm92aWRlcnNbbmFtZV0gJiYgbmFtZS5pbmNsdWRlcygnLicpKSB7XG5cbiAgICAgIGNvbnN0IHBhcnRzID0gbmFtZS5zcGxpdCgnLicpO1xuICAgICAgbGV0IHBpdm90ID0gZ2V0KC8qKiBAdHlwZSB7IHN0cmluZyB9ICovIChwYXJ0cy5zaGlmdCgpKSk7XG5cbiAgICAgIHdoaWxlIChwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgcGl2b3QgPSBwaXZvdFsvKiogQHR5cGUgeyBzdHJpbmcgfSAqLyAocGFydHMuc2hpZnQoKSldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGl2b3Q7XG4gICAgfVxuXG4gICAgaWYgKGhhc093blByb3AoaW5zdGFuY2VzLCBuYW1lKSkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlc1tuYW1lXTtcbiAgICB9XG5cbiAgICBpZiAoaGFzT3duUHJvcChwcm92aWRlcnMsIG5hbWUpKSB7XG4gICAgICBpZiAoY3VycmVudGx5UmVzb2x2aW5nLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgIGN1cnJlbnRseVJlc29sdmluZy5wdXNoKG5hbWUpO1xuICAgICAgICB0aHJvdyBlcnJvcignQ2Fubm90IHJlc29sdmUgY2lyY3VsYXIgZGVwZW5kZW5jeSEnKTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudGx5UmVzb2x2aW5nLnB1c2gobmFtZSk7XG4gICAgICBpbnN0YW5jZXNbbmFtZV0gPSBwcm92aWRlcnNbbmFtZV1bMF0ocHJvdmlkZXJzW25hbWVdWzFdKTtcbiAgICAgIGN1cnJlbnRseVJlc29sdmluZy5wb3AoKTtcblxuICAgICAgcmV0dXJuIGluc3RhbmNlc1tuYW1lXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50LmdldChuYW1lLCBzdHJpY3QpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm5EZWYoZm4sIGxvY2Fscykge1xuXG4gICAgaWYgKHR5cGVvZiBsb2NhbHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBsb2NhbHMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoaXNBcnJheShmbikpIHtcbiAgICAgICAgZm4gPSBhbm5vdGF0ZShmbi5zbGljZSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycm9yKGBDYW5ub3QgaW52b2tlIFwiJHsgZm4gfVwiLiBFeHBlY3RlZCBhIGZ1bmN0aW9uIWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICBjb25zdCBpbmplY3QgPSBmbi4kaW5qZWN0IHx8IHBhcnNlQW5ub3RhdGlvbnMoZm4pO1xuICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IGluamVjdC5tYXAoZGVwID0+IHtcbiAgICAgIGlmIChoYXNPd25Qcm9wKGxvY2FscywgZGVwKSkge1xuICAgICAgICByZXR1cm4gbG9jYWxzW2RlcF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0KGRlcCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZm46IGZuLFxuICAgICAgZGVwZW5kZW5jaWVzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZSB0aGUgZ2l2ZW4gdHlwZSwgaW5qZWN0aW5nIGRlcGVuZGVuY2llcy5cbiAgICpcbiAgICogQHRlbXBsYXRlIFRcbiAgICpcbiAgICogQHBhcmFtIHsgRnVuY3Rpb24gfCBbLi4uc3RyaW5nW10sIEZ1bmN0aW9uIF19IHR5cGVcbiAgICpcbiAgICogQHJldHVybiBUXG4gICAqL1xuICBmdW5jdGlvbiBpbnN0YW50aWF0ZSh0eXBlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZm4sXG4gICAgICBkZXBlbmRlbmNpZXNcbiAgICB9ID0gZm5EZWYodHlwZSk7XG5cbiAgICAvLyBpbnN0YW50aWF0ZSB2YXIgYXJncyBjb25zdHJ1Y3RvclxuICAgIGNvbnN0IENvbnN0cnVjdG9yID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChmbiwgbnVsbCwgLi4uZGVwZW5kZW5jaWVzKTtcblxuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2UgdGhlIGdpdmVuIGZ1bmN0aW9uLCBpbmplY3RpbmcgZGVwZW5kZW5jaWVzLiBSZXR1cm4gdGhlIHJlc3VsdC5cbiAgICpcbiAgICogQHRlbXBsYXRlIFRcbiAgICpcbiAgICogQHBhcmFtIHsgRnVuY3Rpb24gfCBbLi4uc3RyaW5nW10sIEZ1bmN0aW9uIF19IGZ1bmNcbiAgICogQHBhcmFtIHsgT2JqZWN0IH0gW2NvbnRleHRdXG4gICAqIEBwYXJhbSB7IE9iamVjdCB9IFtsb2NhbHNdXG4gICAqXG4gICAqIEByZXR1cm4ge1R9IGludm9jYXRpb24gcmVzdWx0XG4gICAqL1xuICBmdW5jdGlvbiBpbnZva2UoZnVuYywgY29udGV4dCwgbG9jYWxzKSB7XG4gICAgY29uc3Qge1xuICAgICAgZm4sXG4gICAgICBkZXBlbmRlbmNpZXNcbiAgICB9ID0gZm5EZWYoZnVuYywgbG9jYWxzKTtcblxuICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBkZXBlbmRlbmNpZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SW5qZWN0b3J9IGNoaWxkSW5qZWN0b3JcbiAgICpcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVQcml2YXRlSW5qZWN0b3JGYWN0b3J5KGNoaWxkSW5qZWN0b3IpIHtcbiAgICByZXR1cm4gYW5ub3RhdGUoa2V5ID0+IGNoaWxkSW5qZWN0b3IuZ2V0KGtleSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TW9kdWxlRGVmaW5pdGlvbltdfSBtb2R1bGVzXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IFtmb3JjZU5ld0luc3RhbmNlc11cbiAgICpcbiAgICogQHJldHVybiB7SW5qZWN0b3J9XG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVDaGlsZChtb2R1bGVzLCBmb3JjZU5ld0luc3RhbmNlcykge1xuICAgIGlmIChmb3JjZU5ld0luc3RhbmNlcyAmJiBmb3JjZU5ld0luc3RhbmNlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGZyb21QYXJlbnRNb2R1bGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgY29uc3QgbWF0Y2hlZFNjb3BlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIGNvbnN0IHByaXZhdGVJbmplY3RvcnNDYWNoZSA9IFtdO1xuICAgICAgY29uc3QgcHJpdmF0ZUNoaWxkSW5qZWN0b3JzID0gW107XG4gICAgICBjb25zdCBwcml2YXRlQ2hpbGRGYWN0b3JpZXMgPSBbXTtcblxuICAgICAgbGV0IHByb3ZpZGVyO1xuICAgICAgbGV0IGNhY2hlSWR4O1xuICAgICAgbGV0IHByaXZhdGVDaGlsZEluamVjdG9yO1xuICAgICAgbGV0IHByaXZhdGVDaGlsZEluamVjdG9yRmFjdG9yeTtcblxuICAgICAgZm9yIChsZXQgbmFtZSBpbiBwcm92aWRlcnMpIHtcbiAgICAgICAgcHJvdmlkZXIgPSBwcm92aWRlcnNbbmFtZV07XG5cbiAgICAgICAgaWYgKGZvcmNlTmV3SW5zdGFuY2VzLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgaWYgKHByb3ZpZGVyWzJdID09PSAncHJpdmF0ZScpIHtcbiAgICAgICAgICAgIGNhY2hlSWR4ID0gcHJpdmF0ZUluamVjdG9yc0NhY2hlLmluZGV4T2YocHJvdmlkZXJbM10pO1xuICAgICAgICAgICAgaWYgKGNhY2hlSWR4ID09PSAtMSkge1xuICAgICAgICAgICAgICBwcml2YXRlQ2hpbGRJbmplY3RvciA9IHByb3ZpZGVyWzNdLmNyZWF0ZUNoaWxkKFtdLCBmb3JjZU5ld0luc3RhbmNlcyk7XG4gICAgICAgICAgICAgIHByaXZhdGVDaGlsZEluamVjdG9yRmFjdG9yeSA9IGNyZWF0ZVByaXZhdGVJbmplY3RvckZhY3RvcnkocHJpdmF0ZUNoaWxkSW5qZWN0b3IpO1xuICAgICAgICAgICAgICBwcml2YXRlSW5qZWN0b3JzQ2FjaGUucHVzaChwcm92aWRlclszXSk7XG4gICAgICAgICAgICAgIHByaXZhdGVDaGlsZEluamVjdG9ycy5wdXNoKHByaXZhdGVDaGlsZEluamVjdG9yKTtcbiAgICAgICAgICAgICAgcHJpdmF0ZUNoaWxkRmFjdG9yaWVzLnB1c2gocHJpdmF0ZUNoaWxkSW5qZWN0b3JGYWN0b3J5KTtcbiAgICAgICAgICAgICAgZnJvbVBhcmVudE1vZHVsZVtuYW1lXSA9IFsgcHJpdmF0ZUNoaWxkSW5qZWN0b3JGYWN0b3J5LCBuYW1lLCAncHJpdmF0ZScsIHByaXZhdGVDaGlsZEluamVjdG9yIF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tUGFyZW50TW9kdWxlW25hbWVdID0gWyBwcml2YXRlQ2hpbGRGYWN0b3JpZXNbY2FjaGVJZHhdLCBuYW1lLCAncHJpdmF0ZScsIHByaXZhdGVDaGlsZEluamVjdG9yc1tjYWNoZUlkeF0gXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJvbVBhcmVudE1vZHVsZVtuYW1lXSA9IFsgcHJvdmlkZXJbMl0sIHByb3ZpZGVyWzFdIF07XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hdGNoZWRTY29wZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChwcm92aWRlclsyXSA9PT0gJ2ZhY3RvcnknIHx8IHByb3ZpZGVyWzJdID09PSAndHlwZScpICYmIHByb3ZpZGVyWzFdLiRzY29wZSkge1xuICAgICAgICAgIC8qIGpzaGludCAtVzA4MyAqL1xuICAgICAgICAgIGZvcmNlTmV3SW5zdGFuY2VzLmZvckVhY2goc2NvcGUgPT4ge1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVyWzFdLiRzY29wZS5pbmRleE9mKHNjb3BlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgZnJvbVBhcmVudE1vZHVsZVtuYW1lXSA9IFsgcHJvdmlkZXJbMl0sIHByb3ZpZGVyWzFdIF07XG4gICAgICAgICAgICAgIG1hdGNoZWRTY29wZXNbc2NvcGVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3JjZU5ld0luc3RhbmNlcy5mb3JFYWNoKHNjb3BlID0+IHtcbiAgICAgICAgaWYgKCFtYXRjaGVkU2NvcGVzW3Njb3BlXSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcHJvdmlkZXIgZm9yIFwiJyArIHNjb3BlICsgJ1wiLiBDYW5ub3QgdXNlIHByb3ZpZGVyIGZyb20gdGhlIHBhcmVudCEnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIG1vZHVsZXMudW5zaGlmdChmcm9tUGFyZW50TW9kdWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEluamVjdG9yKG1vZHVsZXMsIHNlbGYpO1xuICB9XG5cbiAgY29uc3QgZmFjdG9yeU1hcCA9IHtcbiAgICBmYWN0b3J5OiBpbnZva2UsXG4gICAgdHlwZTogaW5zdGFudGlhdGUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge01vZHVsZURlZmluaXRpb259IG1vZHVsZURlZmluaXRpb25cbiAgICogQHBhcmFtIHtJbmplY3Rvcn0gaW5qZWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxpemVyKG1vZHVsZURlZmluaXRpb24sIGluamVjdG9yKSB7XG5cbiAgICBjb25zdCBpbml0aWFsaXplcnMgPSBtb2R1bGVEZWZpbml0aW9uLl9faW5pdF9fIHx8IFtdO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaW5pdGlhbGl6ZXJzLmZvckVhY2goaW5pdGlhbGl6ZXIgPT4ge1xuXG4gICAgICAgIC8vIGVhZ2VybHkgcmVzb2x2ZSBjb21wb25lbnQgKGZuIG9yIHN0cmluZylcbiAgICAgICAgaWYgKHR5cGVvZiBpbml0aWFsaXplciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpbmplY3Rvci5nZXQoaW5pdGlhbGl6ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluamVjdG9yLmludm9rZShpbml0aWFsaXplcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtNb2R1bGVEZWZpbml0aW9ufSBtb2R1bGVEZWZpbml0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBsb2FkTW9kdWxlKG1vZHVsZURlZmluaXRpb24pIHtcblxuICAgIGNvbnN0IG1vZHVsZUV4cG9ydHMgPSBtb2R1bGVEZWZpbml0aW9uLl9fZXhwb3J0c19fO1xuXG4gICAgLy8gcHJpdmF0ZSBtb2R1bGVcbiAgICBpZiAobW9kdWxlRXhwb3J0cykge1xuICAgICAgY29uc3QgbmVzdGVkTW9kdWxlcyA9IG1vZHVsZURlZmluaXRpb24uX19tb2R1bGVzX187XG5cbiAgICAgIGNvbnN0IGNsb25lZE1vZHVsZSA9IE9iamVjdC5rZXlzKG1vZHVsZURlZmluaXRpb24pLnJlZHVjZSgoY2xvbmVkTW9kdWxlLCBrZXkpID0+IHtcblxuICAgICAgICBpZiAoa2V5ICE9PSAnX19leHBvcnRzX18nICYmIGtleSAhPT0gJ19fbW9kdWxlc19fJyAmJiBrZXkgIT09ICdfX2luaXRfXycgJiYga2V5ICE9PSAnX19kZXBlbmRzX18nKSB7XG4gICAgICAgICAgY2xvbmVkTW9kdWxlW2tleV0gPSBtb2R1bGVEZWZpbml0aW9uW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xvbmVkTW9kdWxlO1xuICAgICAgfSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cbiAgICAgIGNvbnN0IGNoaWxkTW9kdWxlcyA9IChuZXN0ZWRNb2R1bGVzIHx8IFtdKS5jb25jYXQoY2xvbmVkTW9kdWxlKTtcblxuICAgICAgY29uc3QgcHJpdmF0ZUluamVjdG9yID0gY3JlYXRlQ2hpbGQoY2hpbGRNb2R1bGVzKTtcbiAgICAgIGNvbnN0IGdldEZyb21Qcml2YXRlSW5qZWN0b3IgPSBhbm5vdGF0ZShmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHByaXZhdGVJbmplY3Rvci5nZXQoa2V5KTtcbiAgICAgIH0pO1xuXG4gICAgICBtb2R1bGVFeHBvcnRzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHByb3ZpZGVyc1trZXldID0gWyBnZXRGcm9tUHJpdmF0ZUluamVjdG9yLCBrZXksICdwcml2YXRlJywgcHJpdmF0ZUluamVjdG9yIF07XG4gICAgICB9KTtcblxuICAgICAgLy8gZW5zdXJlIGNoaWxkIGluamVjdG9yIGluaXRpYWxpemVzXG4gICAgICBjb25zdCBpbml0aWFsaXplcnMgPSAobW9kdWxlRGVmaW5pdGlvbi5fX2luaXRfXyB8fCBbXSkuc2xpY2UoKTtcblxuICAgICAgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHByaXZhdGVJbmplY3Rvci5pbml0KCk7XG4gICAgICB9KTtcblxuICAgICAgbW9kdWxlRGVmaW5pdGlvbiA9IE9iamVjdC5hc3NpZ24oe30sIG1vZHVsZURlZmluaXRpb24sIHtcbiAgICAgICAgX19pbml0X186IGluaXRpYWxpemVyc1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBjcmVhdGVJbml0aWFsaXplcihtb2R1bGVEZWZpbml0aW9uLCBwcml2YXRlSW5qZWN0b3IpO1xuICAgIH1cblxuICAgIC8vIG5vcm1hbCBtb2R1bGVcbiAgICBPYmplY3Qua2V5cyhtb2R1bGVEZWZpbml0aW9uKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXG4gICAgICBpZiAoa2V5ID09PSAnX19pbml0X18nIHx8IGtleSA9PT0gJ19fZGVwZW5kc19fJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHR5cGVEZWNsYXJhdGlvbiA9IC8qKiBAdHlwZSB7IFR5cGVkRGVjbGFyYXRpb24gfSAqLyAoXG4gICAgICAgIG1vZHVsZURlZmluaXRpb25ba2V5XVxuICAgICAgKTtcblxuICAgICAgaWYgKHR5cGVEZWNsYXJhdGlvblsyXSA9PT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgIHByb3ZpZGVyc1trZXldID0gdHlwZURlY2xhcmF0aW9uO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHR5cGUgPSB0eXBlRGVjbGFyYXRpb25bMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IHR5cGVEZWNsYXJhdGlvblsxXTtcblxuICAgICAgcHJvdmlkZXJzW2tleV0gPSBbIGZhY3RvcnlNYXBbdHlwZV0sIGFycmF5VW53cmFwKHR5cGUsIHZhbHVlKSwgdHlwZSBdO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNyZWF0ZUluaXRpYWxpemVyKG1vZHVsZURlZmluaXRpb24sIHNlbGYpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TW9kdWxlRGVmaW5pdGlvbltdfSBtb2R1bGVEZWZpbml0aW9uc1xuICAgKiBAcGFyYW0ge01vZHVsZURlZmluaXRpb259IG1vZHVsZURlZmluaXRpb25cbiAgICpcbiAgICogQHJldHVybiB7TW9kdWxlRGVmaW5pdGlvbltdfVxuICAgKi9cbiAgZnVuY3Rpb24gcmVzb2x2ZURlcGVuZGVuY2llcyhtb2R1bGVEZWZpbml0aW9ucywgbW9kdWxlRGVmaW5pdGlvbikge1xuXG4gICAgaWYgKG1vZHVsZURlZmluaXRpb25zLmluZGV4T2YobW9kdWxlRGVmaW5pdGlvbikgIT09IC0xKSB7XG4gICAgICByZXR1cm4gbW9kdWxlRGVmaW5pdGlvbnM7XG4gICAgfVxuXG4gICAgbW9kdWxlRGVmaW5pdGlvbnMgPSAobW9kdWxlRGVmaW5pdGlvbi5fX2RlcGVuZHNfXyB8fCBbXSkucmVkdWNlKHJlc29sdmVEZXBlbmRlbmNpZXMsIG1vZHVsZURlZmluaXRpb25zKTtcblxuICAgIGlmIChtb2R1bGVEZWZpbml0aW9ucy5pbmRleE9mKG1vZHVsZURlZmluaXRpb24pICE9PSAtMSkge1xuICAgICAgcmV0dXJuIG1vZHVsZURlZmluaXRpb25zO1xuICAgIH1cblxuICAgIHJldHVybiBtb2R1bGVEZWZpbml0aW9ucy5jb25jYXQobW9kdWxlRGVmaW5pdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtNb2R1bGVEZWZpbml0aW9uW119IG1vZHVsZURlZmluaXRpb25zXG4gICAqXG4gICAqIEByZXR1cm4geyAoKSA9PiB2b2lkIH0gaW5pdGlhbGl6ZXJGblxuICAgKi9cbiAgZnVuY3Rpb24gYm9vdHN0cmFwKG1vZHVsZURlZmluaXRpb25zKSB7XG5cbiAgICBjb25zdCBpbml0aWFsaXplcnMgPSBtb2R1bGVEZWZpbml0aW9uc1xuICAgICAgLnJlZHVjZShyZXNvbHZlRGVwZW5kZW5jaWVzLCBbXSlcbiAgICAgIC5tYXAobG9hZE1vZHVsZSk7XG5cbiAgICBsZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcblxuICAgICAgaWYgKGluaXRpYWxpemVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgICBpbml0aWFsaXplcnMuZm9yRWFjaChpbml0aWFsaXplciA9PiBpbml0aWFsaXplcigpKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gcHVibGljIEFQSVxuICB0aGlzLmdldCA9IGdldDtcbiAgdGhpcy5pbnZva2UgPSBpbnZva2U7XG4gIHRoaXMuaW5zdGFudGlhdGUgPSBpbnN0YW50aWF0ZTtcbiAgdGhpcy5jcmVhdGVDaGlsZCA9IGNyZWF0ZUNoaWxkO1xuXG4gIC8vIHNldHVwXG4gIHRoaXMuaW5pdCA9IGJvb3RzdHJhcChtb2R1bGVzKTtcbn1cblxuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBhcnJheVVud3JhcCh0eXBlLCB2YWx1ZSkge1xuICBpZiAodHlwZSAhPT0gJ3ZhbHVlJyAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgIHZhbHVlID0gYW5ub3RhdGUodmFsdWUuc2xpY2UoKSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCB7IEluamVjdG9yLCBhbm5vdGF0ZSwgcGFyc2VBbm5vdGF0aW9ucyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/didi/dist/index.js\n\n}");

/***/ }),

/***/ "../node_modules/min-dom/dist/index.esm.js":
/*!*************************************************!*\
  !*** ../node_modules/min-dom/dist/index.esm.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assignStyle: () => (/* binding */ assign$1),\n/* harmony export */   attr: () => (/* binding */ attr),\n/* harmony export */   classes: () => (/* binding */ classes),\n/* harmony export */   clear: () => (/* binding */ clear),\n/* harmony export */   closest: () => (/* binding */ closest),\n/* harmony export */   delegate: () => (/* binding */ delegate),\n/* harmony export */   domify: () => (/* binding */ domify),\n/* harmony export */   event: () => (/* binding */ componentEvent),\n/* harmony export */   matches: () => (/* binding */ matchesSelector),\n/* harmony export */   query: () => (/* binding */ query),\n/* harmony export */   queryAll: () => (/* binding */ all),\n/* harmony export */   remove: () => (/* binding */ remove)\n/* harmony export */ });\n/**\n * Flatten array, one level deep.\n *\n * @param {Array<?>} arr\n *\n * @return {Array<?>}\n */\n\nvar nativeToString = Object.prototype.toString;\nvar nativeHasOwnProperty = Object.prototype.hasOwnProperty;\nfunction isUndefined(obj) {\n  return obj === undefined;\n}\nfunction isArray(obj) {\n  return nativeToString.call(obj) === '[object Array]';\n}\n/**\n * Return true, if target owns a property with the given key.\n *\n * @param {Object} target\n * @param {String} key\n *\n * @return {Boolean}\n */\n\nfunction has(target, key) {\n  return nativeHasOwnProperty.call(target, key);\n}\n/**\n * Iterate over collection; returning something\n * (non-undefined) will stop iteration.\n *\n * @param  {Array|Object} collection\n * @param  {Function} iterator\n *\n * @return {Object} return result that stopped the iteration\n */\n\nfunction forEach(collection, iterator) {\n  var val, result;\n\n  if (isUndefined(collection)) {\n    return;\n  }\n\n  var convertKey = isArray(collection) ? toNum : identity;\n\n  for (var key in collection) {\n    if (has(collection, key)) {\n      val = collection[key];\n      result = iterator(val, convertKey(key));\n\n      if (result === false) {\n        return val;\n      }\n    }\n  }\n}\n\nfunction identity(arg) {\n  return arg;\n}\n\nfunction toNum(arg) {\n  return Number(arg);\n}\n\n/**\n * Assigns style attributes in a style-src compliant way.\n *\n * @param {Element} element\n * @param {...Object} styleSources\n *\n * @return {Element} the element\n */\nfunction assign$1(element) {\n  var target = element.style;\n\n  for (var _len = arguments.length, styleSources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    styleSources[_key - 1] = arguments[_key];\n  }\n\n  forEach(styleSources, function (style) {\n    if (!style) {\n      return;\n    }\n\n    forEach(style, function (value, key) {\n      target[key] = value;\n    });\n  });\n\n  return element;\n}\n\n/**\n * Set attribute `name` to `val`, or get attr `name`.\n *\n * @param {Element} el\n * @param {String} name\n * @param {String} [val]\n * @api public\n */\nfunction attr(el, name, val) {\n  // get\n  if (arguments.length == 2) {\n    return el.getAttribute(name);\n  }\n\n  // remove\n  if (val === null) {\n    return el.removeAttribute(name);\n  }\n\n  // set\n  el.setAttribute(name, val);\n\n  return el;\n}\n\nvar indexOf = [].indexOf;\n\nvar indexof = function(arr, obj){\n  if (indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};\n\n/**\n * Taken from https://github.com/component/classes\n *\n * Without the component bits.\n */\n\n/**\n * Whitespace regexp.\n */\n\nvar re = /\\s+/;\n\n/**\n * toString reference.\n */\n\nvar toString = Object.prototype.toString;\n\n/**\n * Wrap `el` in a `ClassList`.\n *\n * @param {Element} el\n * @return {ClassList}\n * @api public\n */\n\nfunction classes(el) {\n  return new ClassList(el);\n}\n\n/**\n * Initialize a new ClassList for `el`.\n *\n * @param {Element} el\n * @api private\n */\n\nfunction ClassList(el) {\n  if (!el || !el.nodeType) {\n    throw new Error('A DOM element reference is required');\n  }\n  this.el = el;\n  this.list = el.classList;\n}\n\n/**\n * Add class `name` if not already present.\n *\n * @param {String} name\n * @return {ClassList}\n * @api public\n */\n\nClassList.prototype.add = function (name) {\n  // classList\n  if (this.list) {\n    this.list.add(name);\n    return this;\n  }\n\n  // fallback\n  var arr = this.array();\n  var i = indexof(arr, name);\n  if (!~i) arr.push(name);\n  this.el.className = arr.join(' ');\n  return this;\n};\n\n/**\n * Remove class `name` when present, or\n * pass a regular expression to remove\n * any which match.\n *\n * @param {String|RegExp} name\n * @return {ClassList}\n * @api public\n */\n\nClassList.prototype.remove = function (name) {\n  if ('[object RegExp]' == toString.call(name)) {\n    return this.removeMatching(name);\n  }\n\n  // classList\n  if (this.list) {\n    this.list.remove(name);\n    return this;\n  }\n\n  // fallback\n  var arr = this.array();\n  var i = indexof(arr, name);\n  if (~i) arr.splice(i, 1);\n  this.el.className = arr.join(' ');\n  return this;\n};\n\n/**\n * Remove all classes matching `re`.\n *\n * @param {RegExp} re\n * @return {ClassList}\n * @api private\n */\n\nClassList.prototype.removeMatching = function (re) {\n  var arr = this.array();\n  for (var i = 0; i < arr.length; i++) {\n    if (re.test(arr[i])) {\n      this.remove(arr[i]);\n    }\n  }\n  return this;\n};\n\n/**\n * Toggle class `name`, can force state via `force`.\n *\n * For browsers that support classList, but do not support `force` yet,\n * the mistake will be detected and corrected.\n *\n * @param {String} name\n * @param {Boolean} force\n * @return {ClassList}\n * @api public\n */\n\nClassList.prototype.toggle = function (name, force) {\n  // classList\n  if (this.list) {\n    if ('undefined' !== typeof force) {\n      if (force !== this.list.toggle(name, force)) {\n        this.list.toggle(name); // toggle again to correct\n      }\n    } else {\n      this.list.toggle(name);\n    }\n    return this;\n  }\n\n  // fallback\n  if ('undefined' !== typeof force) {\n    if (!force) {\n      this.remove(name);\n    } else {\n      this.add(name);\n    }\n  } else {\n    if (this.has(name)) {\n      this.remove(name);\n    } else {\n      this.add(name);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return an array of classes.\n *\n * @return {Array}\n * @api public\n */\n\nClassList.prototype.array = function () {\n  var className = this.el.getAttribute('class') || '';\n  var str = className.replace(/^\\s+|\\s+$/g, '');\n  var arr = str.split(re);\n  if ('' === arr[0]) arr.shift();\n  return arr;\n};\n\n/**\n * Check if class `name` is present.\n *\n * @param {String} name\n * @return {ClassList}\n * @api public\n */\n\nClassList.prototype.has = ClassList.prototype.contains = function (name) {\n  return this.list ? this.list.contains(name) : !!~indexof(this.array(), name);\n};\n\n/**\n * Remove all children from the given element.\n */\nfunction clear(el) {\n\n  var c;\n\n  while (el.childNodes.length) {\n    c = el.childNodes[0];\n    el.removeChild(c);\n  }\n\n  return el;\n}\n\nvar proto = typeof Element !== 'undefined' ? Element.prototype : {};\nvar vendor = proto.matches\n  || proto.matchesSelector\n  || proto.webkitMatchesSelector\n  || proto.mozMatchesSelector\n  || proto.msMatchesSelector\n  || proto.oMatchesSelector;\n\nvar matchesSelector = match;\n\n/**\n * Match `el` to `selector`.\n *\n * @param {Element} el\n * @param {String} selector\n * @return {Boolean}\n * @api public\n */\n\nfunction match(el, selector) {\n  if (!el || el.nodeType !== 1) return false;\n  if (vendor) return vendor.call(el, selector);\n  var nodes = el.parentNode.querySelectorAll(selector);\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i] == el) return true;\n  }\n  return false;\n}\n\n/**\n * Closest\n *\n * @param {Element} el\n * @param {String} selector\n * @param {Boolean} checkYourSelf (optional)\n */\nfunction closest (element, selector, checkYourSelf) {\n  var currentElem = checkYourSelf ? element : element.parentNode;\n\n  while (currentElem && currentElem.nodeType !== document.DOCUMENT_NODE && currentElem.nodeType !== document.DOCUMENT_FRAGMENT_NODE) {\n\n    if (matchesSelector(currentElem, selector)) {\n      return currentElem;\n    }\n\n    currentElem = currentElem.parentNode;\n  }\n\n  return matchesSelector(currentElem, selector) ? currentElem : null;\n}\n\nvar bind$1 = window.addEventListener ? 'addEventListener' : 'attachEvent',\n    unbind = window.removeEventListener ? 'removeEventListener' : 'detachEvent',\n    prefix = bind$1 !== 'addEventListener' ? 'on' : '';\n\n/**\n * Bind `el` event `type` to `fn`.\n *\n * @param {Element} el\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @return {Function}\n * @api public\n */\n\nvar bind_1 = function(el, type, fn, capture){\n  el[bind$1](prefix + type, fn, capture || false);\n  return fn;\n};\n\n/**\n * Unbind `el` event `type`'s callback `fn`.\n *\n * @param {Element} el\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @return {Function}\n * @api public\n */\n\nvar unbind_1 = function(el, type, fn, capture){\n  el[unbind](prefix + type, fn, capture || false);\n  return fn;\n};\n\nvar componentEvent = {\n\tbind: bind_1,\n\tunbind: unbind_1\n};\n\n/**\n * Module dependencies.\n */\n\n/**\n * Delegate event `type` to `selector`\n * and invoke `fn(e)`. A callback function\n * is returned which may be passed to `.unbind()`.\n *\n * @param {Element} el\n * @param {String} selector\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @return {Function}\n * @api public\n */\n\n// Some events don't bubble, so we want to bind to the capture phase instead\n// when delegating.\nvar forceCaptureEvents = ['focus', 'blur'];\n\nfunction bind$2(el, selector, type, fn, capture) {\n  if (forceCaptureEvents.indexOf(type) !== -1) {\n    capture = true;\n  }\n\n  return componentEvent.bind(el, type, function (e) {\n    var target = e.target || e.srcElement;\n    e.delegateTarget = closest(target, selector, true, el);\n    if (e.delegateTarget) {\n      fn.call(el, e);\n    }\n  }, capture);\n}\n\n/**\n * Unbind event `type`'s callback `fn`.\n *\n * @param {Element} el\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @api public\n */\nfunction unbind$1(el, type, fn, capture) {\n  if (forceCaptureEvents.indexOf(type) !== -1) {\n    capture = true;\n  }\n\n  return componentEvent.unbind(el, type, fn, capture);\n}\n\nvar delegate = {\n  bind: bind$2,\n  unbind: unbind$1\n};\n\n/**\n * Expose `parse`.\n */\n\nvar domify = parse;\n\n/**\n * Tests for browser support.\n */\n\nvar innerHTMLBug = false;\nvar bugTestDiv;\nif (typeof document !== 'undefined') {\n  bugTestDiv = document.createElement('div');\n  // Setup\n  bugTestDiv.innerHTML = '  <link/><table></table><a href=\"/a\">a</a><input type=\"checkbox\"/>';\n  // Make sure that link elements get serialized correctly by innerHTML\n  // This requires a wrapper element in IE\n  innerHTMLBug = !bugTestDiv.getElementsByTagName('link').length;\n  bugTestDiv = undefined;\n}\n\n/**\n * Wrap map from jquery.\n */\n\nvar map$1 = {\n  legend: [1, '<fieldset>', '</fieldset>'],\n  tr: [2, '<table><tbody>', '</tbody></table>'],\n  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],\n  // for script/link/style tags to work in IE6-8, you have to wrap\n  // in a div with a non-whitespace character in front, ha!\n  _default: innerHTMLBug ? [1, 'X<div>', '</div>'] : [0, '', '']\n};\n\nmap$1.td =\nmap$1.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];\n\nmap$1.option =\nmap$1.optgroup = [1, '<select multiple=\"multiple\">', '</select>'];\n\nmap$1.thead =\nmap$1.tbody =\nmap$1.colgroup =\nmap$1.caption =\nmap$1.tfoot = [1, '<table>', '</table>'];\n\nmap$1.polyline =\nmap$1.ellipse =\nmap$1.polygon =\nmap$1.circle =\nmap$1.text =\nmap$1.line =\nmap$1.path =\nmap$1.rect =\nmap$1.g = [1, '<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">','</svg>'];\n\n/**\n * Parse `html` and return a DOM Node instance, which could be a TextNode,\n * HTML DOM Node of some kind (<div> for example), or a DocumentFragment\n * instance, depending on the contents of the `html` string.\n *\n * @param {String} html - HTML string to \"domify\"\n * @param {Document} doc - The `document` instance to create the Node for\n * @return {DOMNode} the TextNode, DOM Node, or DocumentFragment instance\n * @api private\n */\n\nfunction parse(html, doc) {\n  if ('string' != typeof html) throw new TypeError('String expected');\n\n  // default to the global `document` object\n  if (!doc) doc = document;\n\n  // tag name\n  var m = /<([\\w:]+)/.exec(html);\n  if (!m) return doc.createTextNode(html);\n\n  html = html.replace(/^\\s+|\\s+$/g, ''); // Remove leading/trailing whitespace\n\n  var tag = m[1];\n\n  // body support\n  if (tag == 'body') {\n    var el = doc.createElement('html');\n    el.innerHTML = html;\n    return el.removeChild(el.lastChild);\n  }\n\n  // wrap map\n  var wrap = map$1[tag] || map$1._default;\n  var depth = wrap[0];\n  var prefix = wrap[1];\n  var suffix = wrap[2];\n  var el = doc.createElement('div');\n  el.innerHTML = prefix + html + suffix;\n  while (depth--) el = el.lastChild;\n\n  // one element\n  if (el.firstChild == el.lastChild) {\n    return el.removeChild(el.firstChild);\n  }\n\n  // several elements\n  var fragment = doc.createDocumentFragment();\n  while (el.firstChild) {\n    fragment.appendChild(el.removeChild(el.firstChild));\n  }\n\n  return fragment;\n}\n\nfunction query(selector, el) {\n  el = el || document;\n\n  return el.querySelector(selector);\n}\n\nfunction all(selector, el) {\n  el = el || document;\n\n  return el.querySelectorAll(selector);\n}\n\nfunction remove(el) {\n  el.parentNode && el.parentNode.removeChild(el);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL21pbi1kb20vZGlzdC9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFdBQVc7QUFDdEI7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBOztBQUVBLDZGQUE2RixhQUFhO0FBQzFHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FB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QUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUM7O0FBRXpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFeUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYW11bmRhLW1vZGVsZXItY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9taW4tZG9tL2Rpc3QvaW5kZXguZXNtLmpzPzNhMDciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBGbGF0dGVuIGFycmF5LCBvbmUgbGV2ZWwgZGVlcC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PD8+fSBhcnJcbiAqXG4gKiBAcmV0dXJuIHtBcnJheTw/Pn1cbiAqL1xuXG52YXIgbmF0aXZlVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIG5hdGl2ZUhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKG9iaikge1xuICByZXR1cm4gb2JqID09PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICByZXR1cm4gbmF0aXZlVG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSwgaWYgdGFyZ2V0IG93bnMgYSBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBrZXkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaGFzKHRhcmdldCwga2V5KSB7XG4gIHJldHVybiBuYXRpdmVIYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KTtcbn1cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGNvbGxlY3Rpb247IHJldHVybmluZyBzb21ldGhpbmdcbiAqIChub24tdW5kZWZpbmVkKSB3aWxsIHN0b3AgaXRlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fE9iamVjdH0gY29sbGVjdGlvblxuICogQHBhcmFtICB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSByZXR1cm4gcmVzdWx0IHRoYXQgc3RvcHBlZCB0aGUgaXRlcmF0aW9uXG4gKi9cblxuZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRvcikge1xuICB2YXIgdmFsLCByZXN1bHQ7XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGNvbGxlY3Rpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvbnZlcnRLZXkgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gdG9OdW0gOiBpZGVudGl0eTtcblxuICBmb3IgKHZhciBrZXkgaW4gY29sbGVjdGlvbikge1xuICAgIGlmIChoYXMoY29sbGVjdGlvbiwga2V5KSkge1xuICAgICAgdmFsID0gY29sbGVjdGlvbltrZXldO1xuICAgICAgcmVzdWx0ID0gaXRlcmF0b3IodmFsLCBjb252ZXJ0S2V5KGtleSkpO1xuXG4gICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpZGVudGl0eShhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn1cblxuZnVuY3Rpb24gdG9OdW0oYXJnKSB7XG4gIHJldHVybiBOdW1iZXIoYXJnKTtcbn1cblxuLyoqXG4gKiBBc3NpZ25zIHN0eWxlIGF0dHJpYnV0ZXMgaW4gYSBzdHlsZS1zcmMgY29tcGxpYW50IHdheS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzdHlsZVNvdXJjZXNcbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fSB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBhc3NpZ24kMShlbGVtZW50KSB7XG4gIHZhciB0YXJnZXQgPSBlbGVtZW50LnN0eWxlO1xuXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzdHlsZVNvdXJjZXMgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc3R5bGVTb3VyY2VzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGZvckVhY2goc3R5bGVTb3VyY2VzLCBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICBpZiAoIXN0eWxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yRWFjaChzdHlsZSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBlbGVtZW50O1xufVxuXG4vKipcbiAqIFNldCBhdHRyaWJ1dGUgYG5hbWVgIHRvIGB2YWxgLCBvciBnZXQgYXR0ciBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbdmFsXVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gYXR0cihlbCwgbmFtZSwgdmFsKSB7XG4gIC8vIGdldFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgfVxuXG4gIC8vIHJlbW92ZVxuICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGVsLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfVxuXG4gIC8vIHNldFxuICBlbC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsKTtcblxuICByZXR1cm4gZWw7XG59XG5cbnZhciBpbmRleE9mID0gW10uaW5kZXhPZjtcblxudmFyIGluZGV4b2YgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gIGlmIChpbmRleE9mKSByZXR1cm4gYXJyLmluZGV4T2Yob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn07XG5cbi8qKlxuICogVGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vY29tcG9uZW50L2NsYXNzZXNcbiAqXG4gKiBXaXRob3V0IHRoZSBjb21wb25lbnQgYml0cy5cbiAqL1xuXG4vKipcbiAqIFdoaXRlc3BhY2UgcmVnZXhwLlxuICovXG5cbnZhciByZSA9IC9cXHMrLztcblxuLyoqXG4gKiB0b1N0cmluZyByZWZlcmVuY2UuXG4gKi9cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBXcmFwIGBlbGAgaW4gYSBgQ2xhc3NMaXN0YC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtDbGFzc0xpc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNsYXNzZXMoZWwpIHtcbiAgcmV0dXJuIG5ldyBDbGFzc0xpc3QoZWwpO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgQ2xhc3NMaXN0IGZvciBgZWxgLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIENsYXNzTGlzdChlbCkge1xuICBpZiAoIWVsIHx8ICFlbC5ub2RlVHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQSBET00gZWxlbWVudCByZWZlcmVuY2UgaXMgcmVxdWlyZWQnKTtcbiAgfVxuICB0aGlzLmVsID0gZWw7XG4gIHRoaXMubGlzdCA9IGVsLmNsYXNzTGlzdDtcbn1cblxuLyoqXG4gKiBBZGQgY2xhc3MgYG5hbWVgIGlmIG5vdCBhbHJlYWR5IHByZXNlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ2xhc3NMaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAvLyBjbGFzc0xpc3RcbiAgaWYgKHRoaXMubGlzdCkge1xuICAgIHRoaXMubGlzdC5hZGQobmFtZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBmYWxsYmFja1xuICB2YXIgYXJyID0gdGhpcy5hcnJheSgpO1xuICB2YXIgaSA9IGluZGV4b2YoYXJyLCBuYW1lKTtcbiAgaWYgKCF+aSkgYXJyLnB1c2gobmFtZSk7XG4gIHRoaXMuZWwuY2xhc3NOYW1lID0gYXJyLmpvaW4oJyAnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyBgbmFtZWAgd2hlbiBwcmVzZW50LCBvclxuICogcGFzcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byByZW1vdmVcbiAqIGFueSB3aGljaCBtYXRjaC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IG5hbWVcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ2xhc3NMaXN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICBpZiAoJ1tvYmplY3QgUmVnRXhwXScgPT0gdG9TdHJpbmcuY2FsbChuYW1lKSkge1xuICAgIHJldHVybiB0aGlzLnJlbW92ZU1hdGNoaW5nKG5hbWUpO1xuICB9XG5cbiAgLy8gY2xhc3NMaXN0XG4gIGlmICh0aGlzLmxpc3QpIHtcbiAgICB0aGlzLmxpc3QucmVtb3ZlKG5hbWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZmFsbGJhY2tcbiAgdmFyIGFyciA9IHRoaXMuYXJyYXkoKTtcbiAgdmFyIGkgPSBpbmRleG9mKGFyciwgbmFtZSk7XG4gIGlmICh+aSkgYXJyLnNwbGljZShpLCAxKTtcbiAgdGhpcy5lbC5jbGFzc05hbWUgPSBhcnIuam9pbignICcpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBjbGFzc2VzIG1hdGNoaW5nIGByZWAuXG4gKlxuICogQHBhcmFtIHtSZWdFeHB9IHJlXG4gKiBAcmV0dXJuIHtDbGFzc0xpc3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5DbGFzc0xpc3QucHJvdG90eXBlLnJlbW92ZU1hdGNoaW5nID0gZnVuY3Rpb24gKHJlKSB7XG4gIHZhciBhcnIgPSB0aGlzLmFycmF5KCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHJlLnRlc3QoYXJyW2ldKSkge1xuICAgICAgdGhpcy5yZW1vdmUoYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRvZ2dsZSBjbGFzcyBgbmFtZWAsIGNhbiBmb3JjZSBzdGF0ZSB2aWEgYGZvcmNlYC5cbiAqXG4gKiBGb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGNsYXNzTGlzdCwgYnV0IGRvIG5vdCBzdXBwb3J0IGBmb3JjZWAgeWV0LFxuICogdGhlIG1pc3Rha2Ugd2lsbCBiZSBkZXRlY3RlZCBhbmQgY29ycmVjdGVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlXG4gKiBAcmV0dXJuIHtDbGFzc0xpc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNsYXNzTGlzdC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKG5hbWUsIGZvcmNlKSB7XG4gIC8vIGNsYXNzTGlzdFxuICBpZiAodGhpcy5saXN0KSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgZm9yY2UpIHtcbiAgICAgIGlmIChmb3JjZSAhPT0gdGhpcy5saXN0LnRvZ2dsZShuYW1lLCBmb3JjZSkpIHtcbiAgICAgICAgdGhpcy5saXN0LnRvZ2dsZShuYW1lKTsgLy8gdG9nZ2xlIGFnYWluIHRvIGNvcnJlY3RcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5saXN0LnRvZ2dsZShuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBmYWxsYmFja1xuICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBmb3JjZSkge1xuICAgIGlmICghZm9yY2UpIHtcbiAgICAgIHRoaXMucmVtb3ZlKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZChuYW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuaGFzKG5hbWUpKSB7XG4gICAgICB0aGlzLnJlbW92ZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGQobmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBvZiBjbGFzc2VzLlxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5DbGFzc0xpc3QucHJvdG90eXBlLmFycmF5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2xhc3NOYW1lID0gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyc7XG4gIHZhciBzdHIgPSBjbGFzc05hbWUucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xuICB2YXIgYXJyID0gc3RyLnNwbGl0KHJlKTtcbiAgaWYgKCcnID09PSBhcnJbMF0pIGFyci5zaGlmdCgpO1xuICByZXR1cm4gYXJyO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBjbGFzcyBgbmFtZWAgaXMgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5DbGFzc0xpc3QucHJvdG90eXBlLmhhcyA9IENsYXNzTGlzdC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gdGhpcy5saXN0ID8gdGhpcy5saXN0LmNvbnRhaW5zKG5hbWUpIDogISF+aW5kZXhvZih0aGlzLmFycmF5KCksIG5hbWUpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGNoaWxkcmVuIGZyb20gdGhlIGdpdmVuIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGNsZWFyKGVsKSB7XG5cbiAgdmFyIGM7XG5cbiAgd2hpbGUgKGVsLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgYyA9IGVsLmNoaWxkTm9kZXNbMF07XG4gICAgZWwucmVtb3ZlQ2hpbGQoYyk7XG4gIH1cblxuICByZXR1cm4gZWw7XG59XG5cbnZhciBwcm90byA9IHR5cGVvZiBFbGVtZW50ICE9PSAndW5kZWZpbmVkJyA/IEVsZW1lbnQucHJvdG90eXBlIDoge307XG52YXIgdmVuZG9yID0gcHJvdG8ubWF0Y2hlc1xuICB8fCBwcm90by5tYXRjaGVzU2VsZWN0b3JcbiAgfHwgcHJvdG8ud2Via2l0TWF0Y2hlc1NlbGVjdG9yXG4gIHx8IHByb3RvLm1vek1hdGNoZXNTZWxlY3RvclxuICB8fCBwcm90by5tc01hdGNoZXNTZWxlY3RvclxuICB8fCBwcm90by5vTWF0Y2hlc1NlbGVjdG9yO1xuXG52YXIgbWF0Y2hlc1NlbGVjdG9yID0gbWF0Y2g7XG5cbi8qKlxuICogTWF0Y2ggYGVsYCB0byBgc2VsZWN0b3JgLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbWF0Y2goZWwsIHNlbGVjdG9yKSB7XG4gIGlmICghZWwgfHwgZWwubm9kZVR5cGUgIT09IDEpIHJldHVybiBmYWxzZTtcbiAgaWYgKHZlbmRvcikgcmV0dXJuIHZlbmRvci5jYWxsKGVsLCBzZWxlY3Rvcik7XG4gIHZhciBub2RlcyA9IGVsLnBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobm9kZXNbaV0gPT0gZWwpIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDbG9zZXN0XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNoZWNrWW91clNlbGYgKG9wdGlvbmFsKVxuICovXG5mdW5jdGlvbiBjbG9zZXN0IChlbGVtZW50LCBzZWxlY3RvciwgY2hlY2tZb3VyU2VsZikge1xuICB2YXIgY3VycmVudEVsZW0gPSBjaGVja1lvdXJTZWxmID8gZWxlbWVudCA6IGVsZW1lbnQucGFyZW50Tm9kZTtcblxuICB3aGlsZSAoY3VycmVudEVsZW0gJiYgY3VycmVudEVsZW0ubm9kZVR5cGUgIT09IGRvY3VtZW50LkRPQ1VNRU5UX05PREUgJiYgY3VycmVudEVsZW0ubm9kZVR5cGUgIT09IGRvY3VtZW50LkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcblxuICAgIGlmIChtYXRjaGVzU2VsZWN0b3IoY3VycmVudEVsZW0sIHNlbGVjdG9yKSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRFbGVtO1xuICAgIH1cblxuICAgIGN1cnJlbnRFbGVtID0gY3VycmVudEVsZW0ucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzU2VsZWN0b3IoY3VycmVudEVsZW0sIHNlbGVjdG9yKSA/IGN1cnJlbnRFbGVtIDogbnVsbDtcbn1cblxudmFyIGJpbmQkMSA9IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ2F0dGFjaEV2ZW50JyxcbiAgICB1bmJpbmQgPSB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciA/ICdyZW1vdmVFdmVudExpc3RlbmVyJyA6ICdkZXRhY2hFdmVudCcsXG4gICAgcHJlZml4ID0gYmluZCQxICE9PSAnYWRkRXZlbnRMaXN0ZW5lcicgPyAnb24nIDogJyc7XG5cbi8qKlxuICogQmluZCBgZWxgIGV2ZW50IGB0eXBlYCB0byBgZm5gLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudmFyIGJpbmRfMSA9IGZ1bmN0aW9uKGVsLCB0eXBlLCBmbiwgY2FwdHVyZSl7XG4gIGVsW2JpbmQkMV0ocHJlZml4ICsgdHlwZSwgZm4sIGNhcHR1cmUgfHwgZmFsc2UpO1xuICByZXR1cm4gZm47XG59O1xuXG4vKipcbiAqIFVuYmluZCBgZWxgIGV2ZW50IGB0eXBlYCdzIGNhbGxiYWNrIGBmbmAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmVcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG52YXIgdW5iaW5kXzEgPSBmdW5jdGlvbihlbCwgdHlwZSwgZm4sIGNhcHR1cmUpe1xuICBlbFt1bmJpbmRdKHByZWZpeCArIHR5cGUsIGZuLCBjYXB0dXJlIHx8IGZhbHNlKTtcbiAgcmV0dXJuIGZuO1xufTtcblxudmFyIGNvbXBvbmVudEV2ZW50ID0ge1xuXHRiaW5kOiBiaW5kXzEsXG5cdHVuYmluZDogdW5iaW5kXzFcbn07XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4vKipcbiAqIERlbGVnYXRlIGV2ZW50IGB0eXBlYCB0byBgc2VsZWN0b3JgXG4gKiBhbmQgaW52b2tlIGBmbihlKWAuIEEgY2FsbGJhY2sgZnVuY3Rpb25cbiAqIGlzIHJldHVybmVkIHdoaWNoIG1heSBiZSBwYXNzZWQgdG8gYC51bmJpbmQoKWAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FwdHVyZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8vIFNvbWUgZXZlbnRzIGRvbid0IGJ1YmJsZSwgc28gd2Ugd2FudCB0byBiaW5kIHRvIHRoZSBjYXB0dXJlIHBoYXNlIGluc3RlYWRcbi8vIHdoZW4gZGVsZWdhdGluZy5cbnZhciBmb3JjZUNhcHR1cmVFdmVudHMgPSBbJ2ZvY3VzJywgJ2JsdXInXTtcblxuZnVuY3Rpb24gYmluZCQyKGVsLCBzZWxlY3RvciwgdHlwZSwgZm4sIGNhcHR1cmUpIHtcbiAgaWYgKGZvcmNlQ2FwdHVyZUV2ZW50cy5pbmRleE9mKHR5cGUpICE9PSAtMSkge1xuICAgIGNhcHR1cmUgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGNvbXBvbmVudEV2ZW50LmJpbmQoZWwsIHR5cGUsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcbiAgICBlLmRlbGVnYXRlVGFyZ2V0ID0gY2xvc2VzdCh0YXJnZXQsIHNlbGVjdG9yLCB0cnVlLCBlbCk7XG4gICAgaWYgKGUuZGVsZWdhdGVUYXJnZXQpIHtcbiAgICAgIGZuLmNhbGwoZWwsIGUpO1xuICAgIH1cbiAgfSwgY2FwdHVyZSk7XG59XG5cbi8qKlxuICogVW5iaW5kIGV2ZW50IGB0eXBlYCdzIGNhbGxiYWNrIGBmbmAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmVcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVuYmluZCQxKGVsLCB0eXBlLCBmbiwgY2FwdHVyZSkge1xuICBpZiAoZm9yY2VDYXB0dXJlRXZlbnRzLmluZGV4T2YodHlwZSkgIT09IC0xKSB7XG4gICAgY2FwdHVyZSA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gY29tcG9uZW50RXZlbnQudW5iaW5kKGVsLCB0eXBlLCBmbiwgY2FwdHVyZSk7XG59XG5cbnZhciBkZWxlZ2F0ZSA9IHtcbiAgYmluZDogYmluZCQyLFxuICB1bmJpbmQ6IHVuYmluZCQxXG59O1xuXG4vKipcbiAqIEV4cG9zZSBgcGFyc2VgLlxuICovXG5cbnZhciBkb21pZnkgPSBwYXJzZTtcblxuLyoqXG4gKiBUZXN0cyBmb3IgYnJvd3NlciBzdXBwb3J0LlxuICovXG5cbnZhciBpbm5lckhUTUxCdWcgPSBmYWxzZTtcbnZhciBidWdUZXN0RGl2O1xuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgYnVnVGVzdERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAvLyBTZXR1cFxuICBidWdUZXN0RGl2LmlubmVySFRNTCA9ICcgIDxsaW5rLz48dGFibGU+PC90YWJsZT48YSBocmVmPVwiL2FcIj5hPC9hPjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIi8+JztcbiAgLy8gTWFrZSBzdXJlIHRoYXQgbGluayBlbGVtZW50cyBnZXQgc2VyaWFsaXplZCBjb3JyZWN0bHkgYnkgaW5uZXJIVE1MXG4gIC8vIFRoaXMgcmVxdWlyZXMgYSB3cmFwcGVyIGVsZW1lbnQgaW4gSUVcbiAgaW5uZXJIVE1MQnVnID0gIWJ1Z1Rlc3REaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2xpbmsnKS5sZW5ndGg7XG4gIGJ1Z1Rlc3REaXYgPSB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogV3JhcCBtYXAgZnJvbSBqcXVlcnkuXG4gKi9cblxudmFyIG1hcCQxID0ge1xuICBsZWdlbmQ6IFsxLCAnPGZpZWxkc2V0PicsICc8L2ZpZWxkc2V0PiddLFxuICB0cjogWzIsICc8dGFibGU+PHRib2R5PicsICc8L3Rib2R5PjwvdGFibGU+J10sXG4gIGNvbDogWzIsICc8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPicsICc8L2NvbGdyb3VwPjwvdGFibGU+J10sXG4gIC8vIGZvciBzY3JpcHQvbGluay9zdHlsZSB0YWdzIHRvIHdvcmsgaW4gSUU2LTgsIHlvdSBoYXZlIHRvIHdyYXBcbiAgLy8gaW4gYSBkaXYgd2l0aCBhIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlciBpbiBmcm9udCwgaGEhXG4gIF9kZWZhdWx0OiBpbm5lckhUTUxCdWcgPyBbMSwgJ1g8ZGl2PicsICc8L2Rpdj4nXSA6IFswLCAnJywgJyddXG59O1xuXG5tYXAkMS50ZCA9XG5tYXAkMS50aCA9IFszLCAnPHRhYmxlPjx0Ym9keT48dHI+JywgJzwvdHI+PC90Ym9keT48L3RhYmxlPiddO1xuXG5tYXAkMS5vcHRpb24gPVxubWFwJDEub3B0Z3JvdXAgPSBbMSwgJzxzZWxlY3QgbXVsdGlwbGU9XCJtdWx0aXBsZVwiPicsICc8L3NlbGVjdD4nXTtcblxubWFwJDEudGhlYWQgPVxubWFwJDEudGJvZHkgPVxubWFwJDEuY29sZ3JvdXAgPVxubWFwJDEuY2FwdGlvbiA9XG5tYXAkMS50Zm9vdCA9IFsxLCAnPHRhYmxlPicsICc8L3RhYmxlPiddO1xuXG5tYXAkMS5wb2x5bGluZSA9XG5tYXAkMS5lbGxpcHNlID1cbm1hcCQxLnBvbHlnb24gPVxubWFwJDEuY2lyY2xlID1cbm1hcCQxLnRleHQgPVxubWFwJDEubGluZSA9XG5tYXAkMS5wYXRoID1cbm1hcCQxLnJlY3QgPVxubWFwJDEuZyA9IFsxLCAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmVyc2lvbj1cIjEuMVwiPicsJzwvc3ZnPiddO1xuXG4vKipcbiAqIFBhcnNlIGBodG1sYCBhbmQgcmV0dXJuIGEgRE9NIE5vZGUgaW5zdGFuY2UsIHdoaWNoIGNvdWxkIGJlIGEgVGV4dE5vZGUsXG4gKiBIVE1MIERPTSBOb2RlIG9mIHNvbWUga2luZCAoPGRpdj4gZm9yIGV4YW1wbGUpLCBvciBhIERvY3VtZW50RnJhZ21lbnRcbiAqIGluc3RhbmNlLCBkZXBlbmRpbmcgb24gdGhlIGNvbnRlbnRzIG9mIHRoZSBgaHRtbGAgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sIC0gSFRNTCBzdHJpbmcgdG8gXCJkb21pZnlcIlxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jIC0gVGhlIGBkb2N1bWVudGAgaW5zdGFuY2UgdG8gY3JlYXRlIHRoZSBOb2RlIGZvclxuICogQHJldHVybiB7RE9NTm9kZX0gdGhlIFRleHROb2RlLCBET00gTm9kZSwgb3IgRG9jdW1lbnRGcmFnbWVudCBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2UoaHRtbCwgZG9jKSB7XG4gIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgaHRtbCkgdGhyb3cgbmV3IFR5cGVFcnJvcignU3RyaW5nIGV4cGVjdGVkJyk7XG5cbiAgLy8gZGVmYXVsdCB0byB0aGUgZ2xvYmFsIGBkb2N1bWVudGAgb2JqZWN0XG4gIGlmICghZG9jKSBkb2MgPSBkb2N1bWVudDtcblxuICAvLyB0YWcgbmFtZVxuICB2YXIgbSA9IC88KFtcXHc6XSspLy5leGVjKGh0bWwpO1xuICBpZiAoIW0pIHJldHVybiBkb2MuY3JlYXRlVGV4dE5vZGUoaHRtbCk7XG5cbiAgaHRtbCA9IGh0bWwucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpOyAvLyBSZW1vdmUgbGVhZGluZy90cmFpbGluZyB3aGl0ZXNwYWNlXG5cbiAgdmFyIHRhZyA9IG1bMV07XG5cbiAgLy8gYm9keSBzdXBwb3J0XG4gIGlmICh0YWcgPT0gJ2JvZHknKSB7XG4gICAgdmFyIGVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2h0bWwnKTtcbiAgICBlbC5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiBlbC5yZW1vdmVDaGlsZChlbC5sYXN0Q2hpbGQpO1xuICB9XG5cbiAgLy8gd3JhcCBtYXBcbiAgdmFyIHdyYXAgPSBtYXAkMVt0YWddIHx8IG1hcCQxLl9kZWZhdWx0O1xuICB2YXIgZGVwdGggPSB3cmFwWzBdO1xuICB2YXIgcHJlZml4ID0gd3JhcFsxXTtcbiAgdmFyIHN1ZmZpeCA9IHdyYXBbMl07XG4gIHZhciBlbCA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZWwuaW5uZXJIVE1MID0gcHJlZml4ICsgaHRtbCArIHN1ZmZpeDtcbiAgd2hpbGUgKGRlcHRoLS0pIGVsID0gZWwubGFzdENoaWxkO1xuXG4gIC8vIG9uZSBlbGVtZW50XG4gIGlmIChlbC5maXJzdENoaWxkID09IGVsLmxhc3RDaGlsZCkge1xuICAgIHJldHVybiBlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcbiAgfVxuXG4gIC8vIHNldmVyYWwgZWxlbWVudHNcbiAgdmFyIGZyYWdtZW50ID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgd2hpbGUgKGVsLmZpcnN0Q2hpbGQpIHtcbiAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKSk7XG4gIH1cblxuICByZXR1cm4gZnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIHF1ZXJ5KHNlbGVjdG9yLCBlbCkge1xuICBlbCA9IGVsIHx8IGRvY3VtZW50O1xuXG4gIHJldHVybiBlbC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbn1cblxuZnVuY3Rpb24gYWxsKHNlbGVjdG9yLCBlbCkge1xuICBlbCA9IGVsIHx8IGRvY3VtZW50O1xuXG4gIHJldHVybiBlbC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKGVsKSB7XG4gIGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG59XG5cbmV4cG9ydCB7IGFzc2lnbiQxIGFzIGFzc2lnblN0eWxlLCBhdHRyLCBjbGFzc2VzLCBjbGVhciwgY2xvc2VzdCwgZGVsZWdhdGUsIGRvbWlmeSwgY29tcG9uZW50RXZlbnQgYXMgZXZlbnQsIG1hdGNoZXNTZWxlY3RvciBhcyBtYXRjaGVzLCBxdWVyeSwgYWxsIGFzIHF1ZXJ5QWxsLCByZW1vdmUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/min-dom/dist/index.esm.js\n\n}");

/***/ }),

/***/ "../node_modules/preact/hooks/dist/hooks.module.js":
/*!*********************************************************!*\
  !*** ../node_modules/preact/hooks/dist/hooks.module.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCallback: () => (/* binding */ T),\n/* harmony export */   useContext: () => (/* binding */ q),\n/* harmony export */   useDebugValue: () => (/* binding */ x),\n/* harmony export */   useEffect: () => (/* binding */ h),\n/* harmony export */   useErrorBoundary: () => (/* binding */ P),\n/* harmony export */   useId: () => (/* binding */ V),\n/* harmony export */   useImperativeHandle: () => (/* binding */ A),\n/* harmony export */   useLayoutEffect: () => (/* binding */ s),\n/* harmony export */   useMemo: () => (/* binding */ F),\n/* harmony export */   useReducer: () => (/* binding */ y),\n/* harmony export */   useRef: () => (/* binding */ _),\n/* harmony export */   useState: () => (/* binding */ p)\n/* harmony export */ });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"../node_modules/preact/dist/preact.module.js\");\nvar t,r,u,i,o=0,f=[],c=[],e=preact__WEBPACK_IMPORTED_MODULE_0__.options.__b,a=preact__WEBPACK_IMPORTED_MODULE_0__.options.__r,v=preact__WEBPACK_IMPORTED_MODULE_0__.options.diffed,l=preact__WEBPACK_IMPORTED_MODULE_0__.options.__c,m=preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount;function d(t,u){preact__WEBPACK_IMPORTED_MODULE_0__.options.__h&&preact__WEBPACK_IMPORTED_MODULE_0__.options.__h(r,t,o||u),o=0;var i=r.__H||(r.__H={__:[],__h:[]});return t>=i.__.length&&i.__.push({__V:c}),i.__[t]}function p(n){return o=1,y(B,n)}function y(n,u,i){var o=d(t++,2);if(o.t=n,!o.__c&&(o.__=[i?i(u):B(void 0,u),function(n){var t=o.__N?o.__N[0]:o.__[0],r=o.t(t,n);t!==r&&(o.__N=[r,o.__[1]],o.__c.setState({}))}],o.__c=r,!r.u)){r.u=!0;var f=r.shouldComponentUpdate;r.shouldComponentUpdate=function(n,t,r){if(!o.__c.__H)return!0;var u=o.__c.__H.__.filter(function(n){return n.__c});if(u.every(function(n){return!n.__N}))return!f||f.call(this,n,t,r);var i=!1;return u.forEach(function(n){if(n.__N){var t=n.__[0];n.__=n.__N,n.__N=void 0,t!==n.__[0]&&(i=!0)}}),!(!i&&o.__c.props===n)&&(!f||f.call(this,n,t,r))}}return o.__N||o.__}function h(u,i){var o=d(t++,3);!preact__WEBPACK_IMPORTED_MODULE_0__.options.__s&&z(o.__H,i)&&(o.__=u,o.i=i,r.__H.__h.push(o))}function s(u,i){var o=d(t++,4);!preact__WEBPACK_IMPORTED_MODULE_0__.options.__s&&z(o.__H,i)&&(o.__=u,o.i=i,r.__h.push(o))}function _(n){return o=5,F(function(){return{current:n}},[])}function A(n,t,r){o=6,s(function(){return\"function\"==typeof n?(n(t()),function(){return n(null)}):n?(n.current=t(),function(){return n.current=null}):void 0},null==r?r:r.concat(n))}function F(n,r){var u=d(t++,7);return z(u.__H,r)?(u.__V=n(),u.i=r,u.__h=n,u.__V):u.__}function T(n,t){return o=8,F(function(){return n},t)}function q(n){var u=r.context[n.__c],i=d(t++,9);return i.c=n,u?(null==i.__&&(i.__=!0,u.sub(r)),u.props.value):n.__}function x(t,r){preact__WEBPACK_IMPORTED_MODULE_0__.options.useDebugValue&&preact__WEBPACK_IMPORTED_MODULE_0__.options.useDebugValue(r?r(t):t)}function P(n){var u=d(t++,10),i=p();return u.__=n,r.componentDidCatch||(r.componentDidCatch=function(n,t){u.__&&u.__(n,t),i[1](n)}),[i[0],function(){i[1](void 0)}]}function V(){var n=d(t++,11);if(!n.__){for(var u=r.__v;null!==u&&!u.__m&&null!==u.__;)u=u.__;var i=u.__m||(u.__m=[0,0]);n.__=\"P\"+i[0]+\"-\"+i[1]++}return n.__}function b(){for(var t;t=f.shift();)if(t.__P&&t.__H)try{t.__H.__h.forEach(k),t.__H.__h.forEach(w),t.__H.__h=[]}catch(r){t.__H.__h=[],preact__WEBPACK_IMPORTED_MODULE_0__.options.__e(r,t.__v)}}preact__WEBPACK_IMPORTED_MODULE_0__.options.__b=function(n){r=null,e&&e(n)},preact__WEBPACK_IMPORTED_MODULE_0__.options.__r=function(n){a&&a(n),t=0;var i=(r=n.__c).__H;i&&(u===r?(i.__h=[],r.__h=[],i.__.forEach(function(n){n.__N&&(n.__=n.__N),n.__V=c,n.__N=n.i=void 0})):(i.__h.forEach(k),i.__h.forEach(w),i.__h=[])),u=r},preact__WEBPACK_IMPORTED_MODULE_0__.options.diffed=function(t){v&&v(t);var o=t.__c;o&&o.__H&&(o.__H.__h.length&&(1!==f.push(o)&&i===preact__WEBPACK_IMPORTED_MODULE_0__.options.requestAnimationFrame||((i=preact__WEBPACK_IMPORTED_MODULE_0__.options.requestAnimationFrame)||j)(b)),o.__H.__.forEach(function(n){n.i&&(n.__H=n.i),n.__V!==c&&(n.__=n.__V),n.i=void 0,n.__V=c})),u=r=null},preact__WEBPACK_IMPORTED_MODULE_0__.options.__c=function(t,r){r.some(function(t){try{t.__h.forEach(k),t.__h=t.__h.filter(function(n){return!n.__||w(n)})}catch(u){r.some(function(n){n.__h&&(n.__h=[])}),r=[],preact__WEBPACK_IMPORTED_MODULE_0__.options.__e(u,t.__v)}}),l&&l(t,r)},preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount=function(t){m&&m(t);var r,u=t.__c;u&&u.__H&&(u.__H.__.forEach(function(n){try{k(n)}catch(n){r=n}}),u.__H=void 0,r&&preact__WEBPACK_IMPORTED_MODULE_0__.options.__e(r,u.__v))};var g=\"function\"==typeof requestAnimationFrame;function j(n){var t,r=function(){clearTimeout(u),g&&cancelAnimationFrame(t),setTimeout(n)},u=setTimeout(r,100);g&&(t=requestAnimationFrame(r))}function k(n){var t=r,u=n.__c;\"function\"==typeof u&&(n.__c=void 0,u()),r=t}function w(n){var t=r;n.__c=n.__(),r=t}function z(n,t){return!n||n.length!==t.length||t.some(function(t,r){return t!==n[r]})}function B(n,t){return\"function\"==typeof t?t(n):t}\n//# sourceMappingURL=hooks.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC9ob29rcy9kaXN0L2hvb2tzLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQWlDLDRCQUE0QiwyQ0FBQyxPQUFPLDJDQUFDLE9BQU8sMkNBQUMsVUFBVSwyQ0FBQyxPQUFPLDJDQUFDLFNBQVMsZ0JBQWdCLDJDQUFDLE1BQU0sMkNBQUMsbUJBQW1CLHFCQUFxQixhQUFhLEVBQUUsa0NBQWtDLE1BQU0sVUFBVSxjQUFjLGtCQUFrQixrQkFBa0IsZUFBZSx1REFBdUQsd0NBQXdDLDJDQUEyQyxHQUFHLGlCQUFpQixPQUFPLDhCQUE4Qix3Q0FBd0MsdUJBQXVCLHNDQUFzQyxhQUFhLEVBQUUsdUJBQXVCLGFBQWEsK0JBQStCLFNBQVMsNkJBQTZCLFVBQVUsY0FBYyw2Q0FBNkMsb0RBQW9ELG1CQUFtQixnQkFBZ0IsZUFBZSxDQUFDLDJDQUFDLG1EQUFtRCxnQkFBZ0IsZUFBZSxDQUFDLDJDQUFDLCtDQUErQyxjQUFjLHdCQUF3QixPQUFPLFdBQVcsS0FBSyxrQkFBa0IsaUJBQWlCLDhDQUE4QyxlQUFlLDhCQUE4QixzQkFBc0IsU0FBUyx3QkFBd0IsZ0JBQWdCLGVBQWUsdURBQXVELGdCQUFnQix3QkFBd0IsU0FBUyxJQUFJLGNBQWMsa0NBQWtDLG1FQUFtRSxnQkFBZ0IsMkNBQUMsZ0JBQWdCLDJDQUFDLHlCQUF5QixjQUFjLHNCQUFzQixzRUFBc0Usd0JBQXdCLG1CQUFtQixhQUFhLEVBQUUsYUFBYSxnQkFBZ0IsVUFBVSxnQkFBZ0IsOEJBQThCLFFBQVEsMkJBQTJCLHlCQUF5QixZQUFZLGFBQWEsVUFBVSxZQUFZLHFCQUFxQix1REFBdUQsU0FBUyxhQUFhLDJDQUFDLGVBQWUsMkNBQUMsaUJBQWlCLGVBQWUsQ0FBQywyQ0FBQyxpQkFBaUIsWUFBWSxvQkFBb0Isc0RBQXNELDZDQUE2QyxxREFBcUQsQ0FBQywyQ0FBQyxvQkFBb0IsUUFBUSxZQUFZLGlEQUFpRCwyQ0FBQyw0QkFBNEIsMkNBQUMsNkRBQTZELDREQUE0RCxZQUFZLENBQUMsMkNBQUMsbUJBQW1CLG1CQUFtQixJQUFJLGdEQUFnRCxrQkFBa0IsRUFBRSxTQUFTLG1CQUFtQixrQkFBa0IsT0FBTywyQ0FBQyxlQUFlLFlBQVksQ0FBQywyQ0FBQyxxQkFBcUIsUUFBUSxjQUFjLHdDQUF3QyxJQUFJLEtBQUssU0FBUyxLQUFLLGtCQUFrQiwyQ0FBQyxnQkFBZ0IsK0NBQStDLGNBQWMsbUJBQW1CLHlEQUF5RCxxQkFBcUIsZ0NBQWdDLGNBQWMsZ0JBQWdCLDZDQUE2QyxjQUFjLFFBQVEsaUJBQWlCLGdCQUFnQixvREFBb0QsZ0JBQWdCLEVBQUUsZ0JBQWdCLGtDQUFtUDtBQUNoOEciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYW11bmRhLW1vZGVsZXItY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9wcmVhY3QvaG9va3MvZGlzdC9ob29rcy5tb2R1bGUuanM/NDExNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnR7b3B0aW9ucyBhcyBufWZyb21cInByZWFjdFwiO3ZhciB0LHIsdSxpLG89MCxmPVtdLGM9W10sZT1uLl9fYixhPW4uX19yLHY9bi5kaWZmZWQsbD1uLl9fYyxtPW4udW5tb3VudDtmdW5jdGlvbiBkKHQsdSl7bi5fX2gmJm4uX19oKHIsdCxvfHx1KSxvPTA7dmFyIGk9ci5fX0h8fChyLl9fSD17X186W10sX19oOltdfSk7cmV0dXJuIHQ+PWkuX18ubGVuZ3RoJiZpLl9fLnB1c2goe19fVjpjfSksaS5fX1t0XX1mdW5jdGlvbiBwKG4pe3JldHVybiBvPTEseShCLG4pfWZ1bmN0aW9uIHkobix1LGkpe3ZhciBvPWQodCsrLDIpO2lmKG8udD1uLCFvLl9fYyYmKG8uX189W2k/aSh1KTpCKHZvaWQgMCx1KSxmdW5jdGlvbihuKXt2YXIgdD1vLl9fTj9vLl9fTlswXTpvLl9fWzBdLHI9by50KHQsbik7dCE9PXImJihvLl9fTj1bcixvLl9fWzFdXSxvLl9fYy5zZXRTdGF0ZSh7fSkpfV0sby5fX2M9ciwhci51KSl7ci51PSEwO3ZhciBmPXIuc2hvdWxkQ29tcG9uZW50VXBkYXRlO3Iuc2hvdWxkQ29tcG9uZW50VXBkYXRlPWZ1bmN0aW9uKG4sdCxyKXtpZighby5fX2MuX19IKXJldHVybiEwO3ZhciB1PW8uX19jLl9fSC5fXy5maWx0ZXIoZnVuY3Rpb24obil7cmV0dXJuIG4uX19jfSk7aWYodS5ldmVyeShmdW5jdGlvbihuKXtyZXR1cm4hbi5fX059KSlyZXR1cm4hZnx8Zi5jYWxsKHRoaXMsbix0LHIpO3ZhciBpPSExO3JldHVybiB1LmZvckVhY2goZnVuY3Rpb24obil7aWYobi5fX04pe3ZhciB0PW4uX19bMF07bi5fXz1uLl9fTixuLl9fTj12b2lkIDAsdCE9PW4uX19bMF0mJihpPSEwKX19KSwhKCFpJiZvLl9fYy5wcm9wcz09PW4pJiYoIWZ8fGYuY2FsbCh0aGlzLG4sdCxyKSl9fXJldHVybiBvLl9fTnx8by5fX31mdW5jdGlvbiBoKHUsaSl7dmFyIG89ZCh0KyssMyk7IW4uX19zJiZ6KG8uX19ILGkpJiYoby5fXz11LG8uaT1pLHIuX19ILl9faC5wdXNoKG8pKX1mdW5jdGlvbiBzKHUsaSl7dmFyIG89ZCh0KyssNCk7IW4uX19zJiZ6KG8uX19ILGkpJiYoby5fXz11LG8uaT1pLHIuX19oLnB1c2gobykpfWZ1bmN0aW9uIF8obil7cmV0dXJuIG89NSxGKGZ1bmN0aW9uKCl7cmV0dXJue2N1cnJlbnQ6bn19LFtdKX1mdW5jdGlvbiBBKG4sdCxyKXtvPTYscyhmdW5jdGlvbigpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIG4/KG4odCgpKSxmdW5jdGlvbigpe3JldHVybiBuKG51bGwpfSk6bj8obi5jdXJyZW50PXQoKSxmdW5jdGlvbigpe3JldHVybiBuLmN1cnJlbnQ9bnVsbH0pOnZvaWQgMH0sbnVsbD09cj9yOnIuY29uY2F0KG4pKX1mdW5jdGlvbiBGKG4scil7dmFyIHU9ZCh0KyssNyk7cmV0dXJuIHoodS5fX0gscik/KHUuX19WPW4oKSx1Lmk9cix1Ll9faD1uLHUuX19WKTp1Ll9ffWZ1bmN0aW9uIFQobix0KXtyZXR1cm4gbz04LEYoZnVuY3Rpb24oKXtyZXR1cm4gbn0sdCl9ZnVuY3Rpb24gcShuKXt2YXIgdT1yLmNvbnRleHRbbi5fX2NdLGk9ZCh0KyssOSk7cmV0dXJuIGkuYz1uLHU/KG51bGw9PWkuX18mJihpLl9fPSEwLHUuc3ViKHIpKSx1LnByb3BzLnZhbHVlKTpuLl9ffWZ1bmN0aW9uIHgodCxyKXtuLnVzZURlYnVnVmFsdWUmJm4udXNlRGVidWdWYWx1ZShyP3IodCk6dCl9ZnVuY3Rpb24gUChuKXt2YXIgdT1kKHQrKywxMCksaT1wKCk7cmV0dXJuIHUuX189bixyLmNvbXBvbmVudERpZENhdGNofHwoci5jb21wb25lbnREaWRDYXRjaD1mdW5jdGlvbihuLHQpe3UuX18mJnUuX18obix0KSxpWzFdKG4pfSksW2lbMF0sZnVuY3Rpb24oKXtpWzFdKHZvaWQgMCl9XX1mdW5jdGlvbiBWKCl7dmFyIG49ZCh0KyssMTEpO2lmKCFuLl9fKXtmb3IodmFyIHU9ci5fX3Y7bnVsbCE9PXUmJiF1Ll9fbSYmbnVsbCE9PXUuX187KXU9dS5fXzt2YXIgaT11Ll9fbXx8KHUuX19tPVswLDBdKTtuLl9fPVwiUFwiK2lbMF0rXCItXCIraVsxXSsrfXJldHVybiBuLl9ffWZ1bmN0aW9uIGIoKXtmb3IodmFyIHQ7dD1mLnNoaWZ0KCk7KWlmKHQuX19QJiZ0Ll9fSCl0cnl7dC5fX0guX19oLmZvckVhY2goayksdC5fX0guX19oLmZvckVhY2godyksdC5fX0guX19oPVtdfWNhdGNoKHIpe3QuX19ILl9faD1bXSxuLl9fZShyLHQuX192KX19bi5fX2I9ZnVuY3Rpb24obil7cj1udWxsLGUmJmUobil9LG4uX19yPWZ1bmN0aW9uKG4pe2EmJmEobiksdD0wO3ZhciBpPShyPW4uX19jKS5fX0g7aSYmKHU9PT1yPyhpLl9faD1bXSxyLl9faD1bXSxpLl9fLmZvckVhY2goZnVuY3Rpb24obil7bi5fX04mJihuLl9fPW4uX19OKSxuLl9fVj1jLG4uX19OPW4uaT12b2lkIDB9KSk6KGkuX19oLmZvckVhY2goayksaS5fX2guZm9yRWFjaCh3KSxpLl9faD1bXSkpLHU9cn0sbi5kaWZmZWQ9ZnVuY3Rpb24odCl7diYmdih0KTt2YXIgbz10Ll9fYztvJiZvLl9fSCYmKG8uX19ILl9faC5sZW5ndGgmJigxIT09Zi5wdXNoKG8pJiZpPT09bi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fCgoaT1uLnJlcXVlc3RBbmltYXRpb25GcmFtZSl8fGopKGIpKSxvLl9fSC5fXy5mb3JFYWNoKGZ1bmN0aW9uKG4pe24uaSYmKG4uX19IPW4uaSksbi5fX1YhPT1jJiYobi5fXz1uLl9fViksbi5pPXZvaWQgMCxuLl9fVj1jfSkpLHU9cj1udWxsfSxuLl9fYz1mdW5jdGlvbih0LHIpe3Iuc29tZShmdW5jdGlvbih0KXt0cnl7dC5fX2guZm9yRWFjaChrKSx0Ll9faD10Ll9faC5maWx0ZXIoZnVuY3Rpb24obil7cmV0dXJuIW4uX198fHcobil9KX1jYXRjaCh1KXtyLnNvbWUoZnVuY3Rpb24obil7bi5fX2gmJihuLl9faD1bXSl9KSxyPVtdLG4uX19lKHUsdC5fX3YpfX0pLGwmJmwodCxyKX0sbi51bm1vdW50PWZ1bmN0aW9uKHQpe20mJm0odCk7dmFyIHIsdT10Ll9fYzt1JiZ1Ll9fSCYmKHUuX19ILl9fLmZvckVhY2goZnVuY3Rpb24obil7dHJ5e2sobil9Y2F0Y2gobil7cj1ufX0pLHUuX19IPXZvaWQgMCxyJiZuLl9fZShyLHUuX192KSl9O3ZhciBnPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZTtmdW5jdGlvbiBqKG4pe3ZhciB0LHI9ZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQodSksZyYmY2FuY2VsQW5pbWF0aW9uRnJhbWUodCksc2V0VGltZW91dChuKX0sdT1zZXRUaW1lb3V0KHIsMTAwKTtnJiYodD1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocikpfWZ1bmN0aW9uIGsobil7dmFyIHQ9cix1PW4uX19jO1wiZnVuY3Rpb25cIj09dHlwZW9mIHUmJihuLl9fYz12b2lkIDAsdSgpKSxyPXR9ZnVuY3Rpb24gdyhuKXt2YXIgdD1yO24uX19jPW4uX18oKSxyPXR9ZnVuY3Rpb24geihuLHQpe3JldHVybiFufHxuLmxlbmd0aCE9PXQubGVuZ3RofHx0LnNvbWUoZnVuY3Rpb24odCxyKXtyZXR1cm4gdCE9PW5bcl19KX1mdW5jdGlvbiBCKG4sdCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdD90KG4pOnR9ZXhwb3J0e1QgYXMgdXNlQ2FsbGJhY2sscSBhcyB1c2VDb250ZXh0LHggYXMgdXNlRGVidWdWYWx1ZSxoIGFzIHVzZUVmZmVjdCxQIGFzIHVzZUVycm9yQm91bmRhcnksViBhcyB1c2VJZCxBIGFzIHVzZUltcGVyYXRpdmVIYW5kbGUscyBhcyB1c2VMYXlvdXRFZmZlY3QsRiBhcyB1c2VNZW1vLHkgYXMgdXNlUmVkdWNlcixfIGFzIHVzZVJlZixwIGFzIHVzZVN0YXRlfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhvb2tzLm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/preact/hooks/dist/hooks.module.js\n\n}");

/***/ })

}]);