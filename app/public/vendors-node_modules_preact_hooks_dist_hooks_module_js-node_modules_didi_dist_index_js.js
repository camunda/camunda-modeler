"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkcamunda_modeler_client"] = self["webpackChunkcamunda_modeler_client"] || []).push([["vendors-node_modules_preact_hooks_dist_hooks_module_js-node_modules_didi_dist_index_js"],{

/***/ "../node_modules/preact/hooks/dist/hooks.module.js"
/*!*********************************************************!*\
  !*** ../node_modules/preact/hooks/dist/hooks.module.js ***!
  \*********************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCallback: () => (/* binding */ q),\n/* harmony export */   useContext: () => (/* binding */ x),\n/* harmony export */   useDebugValue: () => (/* binding */ P),\n/* harmony export */   useEffect: () => (/* binding */ y),\n/* harmony export */   useErrorBoundary: () => (/* binding */ b),\n/* harmony export */   useId: () => (/* binding */ g),\n/* harmony export */   useImperativeHandle: () => (/* binding */ F),\n/* harmony export */   useLayoutEffect: () => (/* binding */ _),\n/* harmony export */   useMemo: () => (/* binding */ T),\n/* harmony export */   useReducer: () => (/* binding */ h),\n/* harmony export */   useRef: () => (/* binding */ A),\n/* harmony export */   useState: () => (/* binding */ d)\n/* harmony export */ });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"../node_modules/preact/dist/preact.module.js\");\nvar t,r,u,i,o=0,f=[],c=preact__WEBPACK_IMPORTED_MODULE_0__.options,e=c.__b,a=c.__r,v=c.diffed,l=c.__c,m=c.unmount,s=c.__;function p(n,t){c.__h&&c.__h(r,n,o||t),o=0;var u=r.__H||(r.__H={__:[],__h:[]});return n>=u.__.length&&u.__.push({}),u.__[n]}function d(n){return o=1,h(D,n)}function h(n,u,i){var o=p(t++,2);if(o.t=n,!o.__c&&(o.__=[i?i(u):D(void 0,u),function(n){var t=o.__N?o.__N[0]:o.__[0],r=o.t(t,n);t!==r&&(o.__N=[r,o.__[1]],o.__c.setState({}))}],o.__c=r,!r.__f)){var f=function(n,t,r){if(!o.__c.__H)return!0;var u=o.__c.__H.__.filter(function(n){return!!n.__c});if(u.every(function(n){return!n.__N}))return!c||c.call(this,n,t,r);var i=o.__c.props!==n;return u.forEach(function(n){if(n.__N){var t=n.__[0];n.__=n.__N,n.__N=void 0,t!==n.__[0]&&(i=!0)}}),c&&c.call(this,n,t,r)||i};r.__f=!0;var c=r.shouldComponentUpdate,e=r.componentWillUpdate;r.componentWillUpdate=function(n,t,r){if(this.__e){var u=c;c=void 0,f(n,t,r),c=u}e&&e.call(this,n,t,r)},r.shouldComponentUpdate=f}return o.__N||o.__}function y(n,u){var i=p(t++,3);!c.__s&&C(i.__H,u)&&(i.__=n,i.u=u,r.__H.__h.push(i))}function _(n,u){var i=p(t++,4);!c.__s&&C(i.__H,u)&&(i.__=n,i.u=u,r.__h.push(i))}function A(n){return o=5,T(function(){return{current:n}},[])}function F(n,t,r){o=6,_(function(){if(\"function\"==typeof n){var r=n(t());return function(){n(null),r&&\"function\"==typeof r&&r()}}if(n)return n.current=t(),function(){return n.current=null}},null==r?r:r.concat(n))}function T(n,r){var u=p(t++,7);return C(u.__H,r)&&(u.__=n(),u.__H=r,u.__h=n),u.__}function q(n,t){return o=8,T(function(){return n},t)}function x(n){var u=r.context[n.__c],i=p(t++,9);return i.c=n,u?(null==i.__&&(i.__=!0,u.sub(r)),u.props.value):n.__}function P(n,t){c.useDebugValue&&c.useDebugValue(t?t(n):n)}function b(n){var u=p(t++,10),i=d();return u.__=n,r.componentDidCatch||(r.componentDidCatch=function(n,t){u.__&&u.__(n,t),i[1](n)}),[i[0],function(){i[1](void 0)}]}function g(){var n=p(t++,11);if(!n.__){for(var u=r.__v;null!==u&&!u.__m&&null!==u.__;)u=u.__;var i=u.__m||(u.__m=[0,0]);n.__=\"P\"+i[0]+\"-\"+i[1]++}return n.__}function j(){for(var n;n=f.shift();)if(n.__P&&n.__H)try{n.__H.__h.forEach(z),n.__H.__h.forEach(B),n.__H.__h=[]}catch(t){n.__H.__h=[],c.__e(t,n.__v)}}c.__b=function(n){r=null,e&&e(n)},c.__=function(n,t){n&&t.__k&&t.__k.__m&&(n.__m=t.__k.__m),s&&s(n,t)},c.__r=function(n){a&&a(n),t=0;var i=(r=n.__c).__H;i&&(u===r?(i.__h=[],r.__h=[],i.__.forEach(function(n){n.__N&&(n.__=n.__N),n.u=n.__N=void 0})):(i.__h.forEach(z),i.__h.forEach(B),i.__h=[],t=0)),u=r},c.diffed=function(n){v&&v(n);var t=n.__c;t&&t.__H&&(t.__H.__h.length&&(1!==f.push(t)&&i===c.requestAnimationFrame||((i=c.requestAnimationFrame)||w)(j)),t.__H.__.forEach(function(n){n.u&&(n.__H=n.u),n.u=void 0})),u=r=null},c.__c=function(n,t){t.some(function(n){try{n.__h.forEach(z),n.__h=n.__h.filter(function(n){return!n.__||B(n)})}catch(r){t.some(function(n){n.__h&&(n.__h=[])}),t=[],c.__e(r,n.__v)}}),l&&l(n,t)},c.unmount=function(n){m&&m(n);var t,r=n.__c;r&&r.__H&&(r.__H.__.forEach(function(n){try{z(n)}catch(n){t=n}}),r.__H=void 0,t&&c.__e(t,r.__v))};var k=\"function\"==typeof requestAnimationFrame;function w(n){var t,r=function(){clearTimeout(u),k&&cancelAnimationFrame(t),setTimeout(n)},u=setTimeout(r,35);k&&(t=requestAnimationFrame(r))}function z(n){var t=r,u=n.__c;\"function\"==typeof u&&(n.__c=void 0,u()),r=t}function B(n){var t=r;n.__c=n.__(),r=t}function C(n,t){return!n||n.length!==t.length||t.some(function(t,r){return t!==n[r]})}function D(n,t){return\"function\"==typeof t?t(n):t}\n//# sourceMappingURL=hooks.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC9ob29rcy9kaXN0L2hvb2tzLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQWlDLHVCQUF1QiwyQ0FBQyx1REFBdUQsZ0JBQWdCLDJCQUEyQixxQkFBcUIsYUFBYSxFQUFFLG1DQUFtQyxVQUFVLGNBQWMsa0JBQWtCLGtCQUFrQixlQUFlLHVEQUF1RCx3Q0FBd0MsMkNBQTJDLEdBQUcsbUJBQW1CLHNCQUFzQix1QkFBdUIsc0NBQXNDLGNBQWMsRUFBRSx1QkFBdUIsYUFBYSwrQkFBK0Isc0JBQXNCLDZCQUE2QixVQUFVLGNBQWMsNkNBQTZDLDRCQUE0QixTQUFTLHNEQUFzRCxzQ0FBc0MsYUFBYSxRQUFRLHNCQUFzQixzQkFBc0IsMkJBQTJCLG1CQUFtQixnQkFBZ0IsZUFBZSxxREFBcUQsZ0JBQWdCLGVBQWUsaURBQWlELGNBQWMsd0JBQXdCLE9BQU8sV0FBVyxLQUFLLGtCQUFrQixpQkFBaUIseUJBQXlCLGFBQWEsa0JBQWtCLHNDQUFzQyxxQ0FBcUMsdUJBQXVCLHdCQUF3QixnQkFBZ0IsZUFBZSxtREFBbUQsZ0JBQWdCLHdCQUF3QixTQUFTLElBQUksY0FBYyxrQ0FBa0MsbUVBQW1FLGdCQUFnQiwyQ0FBMkMsY0FBYyxzQkFBc0Isc0VBQXNFLHdCQUF3QixtQkFBbUIsYUFBYSxFQUFFLGFBQWEsZ0JBQWdCLFVBQVUsZ0JBQWdCLDhCQUE4QixRQUFRLDJCQUEyQix5QkFBeUIsWUFBWSxhQUFhLFVBQVUsWUFBWSxxQkFBcUIsdURBQXVELFNBQVMsNkJBQTZCLGtCQUFrQixlQUFlLG9CQUFvQixpREFBaUQsbUJBQW1CLFlBQVksb0JBQW9CLHNEQUFzRCxxQ0FBcUMseURBQXlELHNCQUFzQixRQUFRLFlBQVksNElBQTRJLDRCQUE0QixZQUFZLHFCQUFxQixtQkFBbUIsSUFBSSxnREFBZ0Qsa0JBQWtCLEVBQUUsU0FBUyxtQkFBbUIsa0JBQWtCLHVCQUF1QixZQUFZLHVCQUF1QixRQUFRLGNBQWMsd0NBQXdDLElBQUksS0FBSyxTQUFTLEtBQUssbUNBQW1DLCtDQUErQyxjQUFjLG1CQUFtQix5REFBeUQsb0JBQW9CLGdDQUFnQyxjQUFjLGdCQUFnQiw2Q0FBNkMsY0FBYyxRQUFRLGlCQUFpQixnQkFBZ0Isb0RBQW9ELGdCQUFnQixFQUFFLGdCQUFnQixrQ0FBbVA7QUFDL25IIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2FtdW5kYS1tb2RlbGVyLWNsaWVudC8uLi9ub2RlX21vZHVsZXMvcHJlYWN0L2hvb2tzL2Rpc3QvaG9va3MubW9kdWxlLmpzPzQxMTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0e29wdGlvbnMgYXMgbn1mcm9tXCJwcmVhY3RcIjt2YXIgdCxyLHUsaSxvPTAsZj1bXSxjPW4sZT1jLl9fYixhPWMuX19yLHY9Yy5kaWZmZWQsbD1jLl9fYyxtPWMudW5tb3VudCxzPWMuX187ZnVuY3Rpb24gcChuLHQpe2MuX19oJiZjLl9faChyLG4sb3x8dCksbz0wO3ZhciB1PXIuX19IfHwoci5fX0g9e19fOltdLF9faDpbXX0pO3JldHVybiBuPj11Ll9fLmxlbmd0aCYmdS5fXy5wdXNoKHt9KSx1Ll9fW25dfWZ1bmN0aW9uIGQobil7cmV0dXJuIG89MSxoKEQsbil9ZnVuY3Rpb24gaChuLHUsaSl7dmFyIG89cCh0KyssMik7aWYoby50PW4sIW8uX19jJiYoby5fXz1baT9pKHUpOkQodm9pZCAwLHUpLGZ1bmN0aW9uKG4pe3ZhciB0PW8uX19OP28uX19OWzBdOm8uX19bMF0scj1vLnQodCxuKTt0IT09ciYmKG8uX19OPVtyLG8uX19bMV1dLG8uX19jLnNldFN0YXRlKHt9KSl9XSxvLl9fYz1yLCFyLl9fZikpe3ZhciBmPWZ1bmN0aW9uKG4sdCxyKXtpZighby5fX2MuX19IKXJldHVybiEwO3ZhciB1PW8uX19jLl9fSC5fXy5maWx0ZXIoZnVuY3Rpb24obil7cmV0dXJuISFuLl9fY30pO2lmKHUuZXZlcnkoZnVuY3Rpb24obil7cmV0dXJuIW4uX19OfSkpcmV0dXJuIWN8fGMuY2FsbCh0aGlzLG4sdCxyKTt2YXIgaT1vLl9fYy5wcm9wcyE9PW47cmV0dXJuIHUuZm9yRWFjaChmdW5jdGlvbihuKXtpZihuLl9fTil7dmFyIHQ9bi5fX1swXTtuLl9fPW4uX19OLG4uX19OPXZvaWQgMCx0IT09bi5fX1swXSYmKGk9ITApfX0pLGMmJmMuY2FsbCh0aGlzLG4sdCxyKXx8aX07ci5fX2Y9ITA7dmFyIGM9ci5zaG91bGRDb21wb25lbnRVcGRhdGUsZT1yLmNvbXBvbmVudFdpbGxVcGRhdGU7ci5jb21wb25lbnRXaWxsVXBkYXRlPWZ1bmN0aW9uKG4sdCxyKXtpZih0aGlzLl9fZSl7dmFyIHU9YztjPXZvaWQgMCxmKG4sdCxyKSxjPXV9ZSYmZS5jYWxsKHRoaXMsbix0LHIpfSxyLnNob3VsZENvbXBvbmVudFVwZGF0ZT1mfXJldHVybiBvLl9fTnx8by5fX31mdW5jdGlvbiB5KG4sdSl7dmFyIGk9cCh0KyssMyk7IWMuX19zJiZDKGkuX19ILHUpJiYoaS5fXz1uLGkudT11LHIuX19ILl9faC5wdXNoKGkpKX1mdW5jdGlvbiBfKG4sdSl7dmFyIGk9cCh0KyssNCk7IWMuX19zJiZDKGkuX19ILHUpJiYoaS5fXz1uLGkudT11LHIuX19oLnB1c2goaSkpfWZ1bmN0aW9uIEEobil7cmV0dXJuIG89NSxUKGZ1bmN0aW9uKCl7cmV0dXJue2N1cnJlbnQ6bn19LFtdKX1mdW5jdGlvbiBGKG4sdCxyKXtvPTYsXyhmdW5jdGlvbigpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIG4pe3ZhciByPW4odCgpKTtyZXR1cm4gZnVuY3Rpb24oKXtuKG51bGwpLHImJlwiZnVuY3Rpb25cIj09dHlwZW9mIHImJnIoKX19aWYobilyZXR1cm4gbi5jdXJyZW50PXQoKSxmdW5jdGlvbigpe3JldHVybiBuLmN1cnJlbnQ9bnVsbH19LG51bGw9PXI/cjpyLmNvbmNhdChuKSl9ZnVuY3Rpb24gVChuLHIpe3ZhciB1PXAodCsrLDcpO3JldHVybiBDKHUuX19ILHIpJiYodS5fXz1uKCksdS5fX0g9cix1Ll9faD1uKSx1Ll9ffWZ1bmN0aW9uIHEobix0KXtyZXR1cm4gbz04LFQoZnVuY3Rpb24oKXtyZXR1cm4gbn0sdCl9ZnVuY3Rpb24geChuKXt2YXIgdT1yLmNvbnRleHRbbi5fX2NdLGk9cCh0KyssOSk7cmV0dXJuIGkuYz1uLHU/KG51bGw9PWkuX18mJihpLl9fPSEwLHUuc3ViKHIpKSx1LnByb3BzLnZhbHVlKTpuLl9ffWZ1bmN0aW9uIFAobix0KXtjLnVzZURlYnVnVmFsdWUmJmMudXNlRGVidWdWYWx1ZSh0P3Qobik6bil9ZnVuY3Rpb24gYihuKXt2YXIgdT1wKHQrKywxMCksaT1kKCk7cmV0dXJuIHUuX189bixyLmNvbXBvbmVudERpZENhdGNofHwoci5jb21wb25lbnREaWRDYXRjaD1mdW5jdGlvbihuLHQpe3UuX18mJnUuX18obix0KSxpWzFdKG4pfSksW2lbMF0sZnVuY3Rpb24oKXtpWzFdKHZvaWQgMCl9XX1mdW5jdGlvbiBnKCl7dmFyIG49cCh0KyssMTEpO2lmKCFuLl9fKXtmb3IodmFyIHU9ci5fX3Y7bnVsbCE9PXUmJiF1Ll9fbSYmbnVsbCE9PXUuX187KXU9dS5fXzt2YXIgaT11Ll9fbXx8KHUuX19tPVswLDBdKTtuLl9fPVwiUFwiK2lbMF0rXCItXCIraVsxXSsrfXJldHVybiBuLl9ffWZ1bmN0aW9uIGooKXtmb3IodmFyIG47bj1mLnNoaWZ0KCk7KWlmKG4uX19QJiZuLl9fSCl0cnl7bi5fX0guX19oLmZvckVhY2goeiksbi5fX0guX19oLmZvckVhY2goQiksbi5fX0guX19oPVtdfWNhdGNoKHQpe24uX19ILl9faD1bXSxjLl9fZSh0LG4uX192KX19Yy5fX2I9ZnVuY3Rpb24obil7cj1udWxsLGUmJmUobil9LGMuX189ZnVuY3Rpb24obix0KXtuJiZ0Ll9fayYmdC5fX2suX19tJiYobi5fX209dC5fX2suX19tKSxzJiZzKG4sdCl9LGMuX19yPWZ1bmN0aW9uKG4pe2EmJmEobiksdD0wO3ZhciBpPShyPW4uX19jKS5fX0g7aSYmKHU9PT1yPyhpLl9faD1bXSxyLl9faD1bXSxpLl9fLmZvckVhY2goZnVuY3Rpb24obil7bi5fX04mJihuLl9fPW4uX19OKSxuLnU9bi5fX049dm9pZCAwfSkpOihpLl9faC5mb3JFYWNoKHopLGkuX19oLmZvckVhY2goQiksaS5fX2g9W10sdD0wKSksdT1yfSxjLmRpZmZlZD1mdW5jdGlvbihuKXt2JiZ2KG4pO3ZhciB0PW4uX19jO3QmJnQuX19IJiYodC5fX0guX19oLmxlbmd0aCYmKDEhPT1mLnB1c2godCkmJmk9PT1jLnJlcXVlc3RBbmltYXRpb25GcmFtZXx8KChpPWMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKXx8dykoaikpLHQuX19ILl9fLmZvckVhY2goZnVuY3Rpb24obil7bi51JiYobi5fX0g9bi51KSxuLnU9dm9pZCAwfSkpLHU9cj1udWxsfSxjLl9fYz1mdW5jdGlvbihuLHQpe3Quc29tZShmdW5jdGlvbihuKXt0cnl7bi5fX2guZm9yRWFjaCh6KSxuLl9faD1uLl9faC5maWx0ZXIoZnVuY3Rpb24obil7cmV0dXJuIW4uX198fEIobil9KX1jYXRjaChyKXt0LnNvbWUoZnVuY3Rpb24obil7bi5fX2gmJihuLl9faD1bXSl9KSx0PVtdLGMuX19lKHIsbi5fX3YpfX0pLGwmJmwobix0KX0sYy51bm1vdW50PWZ1bmN0aW9uKG4pe20mJm0obik7dmFyIHQscj1uLl9fYztyJiZyLl9fSCYmKHIuX19ILl9fLmZvckVhY2goZnVuY3Rpb24obil7dHJ5e3oobil9Y2F0Y2gobil7dD1ufX0pLHIuX19IPXZvaWQgMCx0JiZjLl9fZSh0LHIuX192KSl9O3ZhciBrPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZTtmdW5jdGlvbiB3KG4pe3ZhciB0LHI9ZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQodSksayYmY2FuY2VsQW5pbWF0aW9uRnJhbWUodCksc2V0VGltZW91dChuKX0sdT1zZXRUaW1lb3V0KHIsMzUpO2smJih0PXJlcXVlc3RBbmltYXRpb25GcmFtZShyKSl9ZnVuY3Rpb24geihuKXt2YXIgdD1yLHU9bi5fX2M7XCJmdW5jdGlvblwiPT10eXBlb2YgdSYmKG4uX19jPXZvaWQgMCx1KCkpLHI9dH1mdW5jdGlvbiBCKG4pe3ZhciB0PXI7bi5fX2M9bi5fXygpLHI9dH1mdW5jdGlvbiBDKG4sdCl7cmV0dXJuIW58fG4ubGVuZ3RoIT09dC5sZW5ndGh8fHQuc29tZShmdW5jdGlvbih0LHIpe3JldHVybiB0IT09bltyXX0pfWZ1bmN0aW9uIEQobix0KXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3Qobik6dH1leHBvcnR7cSBhcyB1c2VDYWxsYmFjayx4IGFzIHVzZUNvbnRleHQsUCBhcyB1c2VEZWJ1Z1ZhbHVlLHkgYXMgdXNlRWZmZWN0LGIgYXMgdXNlRXJyb3JCb3VuZGFyeSxnIGFzIHVzZUlkLEYgYXMgdXNlSW1wZXJhdGl2ZUhhbmRsZSxfIGFzIHVzZUxheW91dEVmZmVjdCxUIGFzIHVzZU1lbW8saCBhcyB1c2VSZWR1Y2VyLEEgYXMgdXNlUmVmLGQgYXMgdXNlU3RhdGV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG9va3MubW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/preact/hooks/dist/hooks.module.js\n\n}");

/***/ },

/***/ "../node_modules/didi/dist/index.js"
/*!******************************************!*\
  !*** ../node_modules/didi/dist/index.js ***!
  \******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Injector: () => (/* binding */ Injector),\n/* harmony export */   annotate: () => (/* binding */ annotate),\n/* harmony export */   parseAnnotations: () => (/* binding */ parseAnnotations)\n/* harmony export */ });\nconst CLASS_PATTERN = /^class[ {]/;\n\n\n/**\n * @param {function} fn\n *\n * @return {boolean}\n */\nfunction isClass(fn) {\n  return CLASS_PATTERN.test(fn.toString());\n}\n\n/**\n * @param {any} obj\n *\n * @return {boolean}\n */\nfunction isArray(obj) {\n  return Array.isArray(obj);\n}\n\n/**\n * @param {any} obj\n * @param {string} prop\n *\n * @return {boolean}\n */\nfunction hasOwnProp(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n/**\n * @typedef {import('./index.js').InjectAnnotated } InjectAnnotated\n */\n\n/**\n * @template T\n *\n * @params {[...string[], T] | ...string[], T} args\n *\n * @return {T & InjectAnnotated}\n */\nfunction annotate(...args) {\n\n  if (args.length === 1 && isArray(args[0])) {\n    args = args[0];\n  }\n\n  args = [ ...args ];\n\n  const fn = args.pop();\n\n  fn.$inject = args;\n\n  return fn;\n}\n\n\n// Current limitations:\n// - can't put into \"function arg\" comments\n// function /* (no parenthesis like this) */ (){}\n// function abc( /* xx (no parenthesis like this) */ a, b) {}\n//\n// Just put the comment before function or inside:\n// /* (((this is fine))) */ function(a, b) {}\n// function abc(a) { /* (((this is fine))) */}\n//\n// - can't reliably auto-annotate constructor; we'll match the\n// first constructor(...) pattern found which may be the one\n// of a nested class, too.\n\nconst CONSTRUCTOR_ARGS = /constructor\\s*[^(]*\\(\\s*([^)]*)\\)/m;\nconst FN_ARGS = /^(?:async\\s+)?(?:function\\s*[^(]*)?(?:\\(\\s*([^)]*)\\)|(\\w+))/m;\nconst FN_ARG = /\\/\\*([^*]*)\\*\\//m;\n\n/**\n * @param {unknown} fn\n *\n * @return {string[]}\n */\nfunction parseAnnotations(fn) {\n\n  if (typeof fn !== 'function') {\n    throw new Error(`Cannot annotate \"${fn}\". Expected a function!`);\n  }\n\n  const match = fn.toString().match(isClass(fn) ? CONSTRUCTOR_ARGS : FN_ARGS);\n\n  // may parse class without constructor\n  if (!match) {\n    return [];\n  }\n\n  const args = match[1] || match[2];\n\n  return args && args.split(',').map(arg => {\n    const argMatch = arg.match(FN_ARG);\n    return (argMatch && argMatch[1] || arg).trim();\n  }) || [];\n}\n\n/**\n * @typedef { import('./index.js').ModuleDeclaration } ModuleDeclaration\n * @typedef { import('./index.js').ModuleDefinition } ModuleDefinition\n * @typedef { import('./index.js').InjectorContext } InjectorContext\n *\n * @typedef { import('./index.js').TypedDeclaration<any, any> } TypedDeclaration\n */\n\n/**\n * Create a new injector with the given modules.\n *\n * @param {ModuleDefinition[]} modules\n * @param {InjectorContext} [_parent]\n */\nfunction Injector(modules, _parent) {\n\n  const parent = _parent || /** @type InjectorContext */ ({\n    get: function(name, strict) {\n      currentlyResolving.push(name);\n\n      if (strict === false) {\n        return null;\n      } else {\n        throw error(`No provider for \"${ name }\"!`);\n      }\n    }\n  });\n\n  const currentlyResolving = [];\n  const providers = this._providers = Object.create(parent._providers || null);\n  const instances = this._instances = Object.create(null);\n\n  const self = instances.injector = this;\n\n  const error = function(msg) {\n    const stack = currentlyResolving.join(' -> ');\n    currentlyResolving.length = 0;\n    return new Error(stack ? `${ msg } (Resolving: ${ stack })` : msg);\n  };\n\n  /**\n   * Return a named service.\n   *\n   * @param {string} name\n   * @param {boolean} [strict=true] if false, resolve missing services to null\n   *\n   * @return {any}\n   */\n  function get(name, strict) {\n    if (!providers[name] && name.includes('.')) {\n\n      const parts = name.split('.');\n      let pivot = get(/** @type { string } */ (parts.shift()));\n\n      while (parts.length) {\n        pivot = pivot[/** @type { string } */ (parts.shift())];\n      }\n\n      return pivot;\n    }\n\n    if (hasOwnProp(instances, name)) {\n      return instances[name];\n    }\n\n    if (hasOwnProp(providers, name)) {\n      if (currentlyResolving.indexOf(name) !== -1) {\n        currentlyResolving.push(name);\n        throw error('Cannot resolve circular dependency!');\n      }\n\n      currentlyResolving.push(name);\n      instances[name] = providers[name][0](providers[name][1]);\n      currentlyResolving.pop();\n\n      return instances[name];\n    }\n\n    return parent.get(name, strict);\n  }\n\n  function fnDef(fn, locals) {\n\n    if (typeof locals === 'undefined') {\n      locals = {};\n    }\n\n    if (typeof fn !== 'function') {\n      if (isArray(fn)) {\n        fn = annotate(fn.slice());\n      } else {\n        throw error(`Cannot invoke \"${ fn }\". Expected a function!`);\n      }\n    }\n\n    /**\n     * @type {string[]}\n     */\n    const inject = fn.$inject || parseAnnotations(fn);\n    const dependencies = inject.map(dep => {\n      if (hasOwnProp(locals, dep)) {\n        return locals[dep];\n      } else {\n        return get(dep);\n      }\n    });\n\n    return {\n      fn: fn,\n      dependencies\n    };\n  }\n\n  /**\n   * Instantiate the given type, injecting dependencies.\n   *\n   * @template T\n   *\n   * @param { Function | [...string[], Function ]} type\n   *\n   * @return T\n   */\n  function instantiate(type) {\n    const {\n      fn,\n      dependencies\n    } = fnDef(type);\n\n    // instantiate var args constructor\n    const Constructor = Function.prototype.bind.call(fn, null, ...dependencies);\n\n    return new Constructor();\n  }\n\n  /**\n   * Invoke the given function, injecting dependencies. Return the result.\n   *\n   * @template T\n   *\n   * @param { Function | [...string[], Function ]} func\n   * @param { Object } [context]\n   * @param { Object } [locals]\n   *\n   * @return {T} invocation result\n   */\n  function invoke(func, context, locals) {\n    const {\n      fn,\n      dependencies\n    } = fnDef(func, locals);\n\n    return fn.apply(context, dependencies);\n  }\n\n  /**\n   * @param {Injector} childInjector\n   *\n   * @return {Function}\n   */\n  function createPrivateInjectorFactory(childInjector) {\n    return annotate(key => childInjector.get(key));\n  }\n\n  /**\n   * @param {ModuleDefinition[]} modules\n   * @param {string[]} [forceNewInstances]\n   *\n   * @return {Injector}\n   */\n  function createChild(modules, forceNewInstances) {\n    if (forceNewInstances && forceNewInstances.length) {\n      const fromParentModule = Object.create(null);\n      const matchedScopes = Object.create(null);\n\n      const privateInjectorsCache = [];\n      const privateChildInjectors = [];\n      const privateChildFactories = [];\n\n      let provider;\n      let cacheIdx;\n      let privateChildInjector;\n      let privateChildInjectorFactory;\n\n      for (let name in providers) {\n        provider = providers[name];\n\n        if (forceNewInstances.indexOf(name) !== -1) {\n          if (provider[2] === 'private') {\n            cacheIdx = privateInjectorsCache.indexOf(provider[3]);\n            if (cacheIdx === -1) {\n              privateChildInjector = provider[3].createChild([], forceNewInstances);\n              privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);\n              privateInjectorsCache.push(provider[3]);\n              privateChildInjectors.push(privateChildInjector);\n              privateChildFactories.push(privateChildInjectorFactory);\n              fromParentModule[name] = [ privateChildInjectorFactory, name, 'private', privateChildInjector ];\n            } else {\n              fromParentModule[name] = [ privateChildFactories[cacheIdx], name, 'private', privateChildInjectors[cacheIdx] ];\n            }\n          } else {\n            fromParentModule[name] = [ provider[2], provider[1] ];\n          }\n          matchedScopes[name] = true;\n        }\n\n        if ((provider[2] === 'factory' || provider[2] === 'type') && provider[1].$scope) {\n          /* jshint -W083 */\n          forceNewInstances.forEach(scope => {\n            if (provider[1].$scope.indexOf(scope) !== -1) {\n              fromParentModule[name] = [ provider[2], provider[1] ];\n              matchedScopes[scope] = true;\n            }\n          });\n        }\n      }\n\n      forceNewInstances.forEach(scope => {\n        if (!matchedScopes[scope]) {\n          throw new Error('No provider for \"' + scope + '\". Cannot use provider from the parent!');\n        }\n      });\n\n      modules.unshift(fromParentModule);\n    }\n\n    return new Injector(modules, self);\n  }\n\n  const factoryMap = {\n    factory: invoke,\n    type: instantiate,\n    value: function(value) {\n      return value;\n    }\n  };\n\n  /**\n   * @param {ModuleDefinition} moduleDefinition\n   * @param {Injector} injector\n   */\n  function createInitializer(moduleDefinition, injector) {\n\n    const initializers = moduleDefinition.__init__ || [];\n\n    return function() {\n      initializers.forEach(initializer => {\n\n        // eagerly resolve component (fn or string)\n        if (typeof initializer === 'string') {\n          injector.get(initializer);\n        } else {\n          injector.invoke(initializer);\n        }\n      });\n    };\n  }\n\n  /**\n   * @param {ModuleDefinition} moduleDefinition\n   */\n  function loadModule(moduleDefinition) {\n\n    const moduleExports = moduleDefinition.__exports__;\n\n    // private module\n    if (moduleExports) {\n      const nestedModules = moduleDefinition.__modules__;\n\n      const clonedModule = Object.keys(moduleDefinition).reduce((clonedModule, key) => {\n\n        if (key !== '__exports__' && key !== '__modules__' && key !== '__init__' && key !== '__depends__') {\n          clonedModule[key] = moduleDefinition[key];\n        }\n\n        return clonedModule;\n      }, Object.create(null));\n\n      const childModules = (nestedModules || []).concat(clonedModule);\n\n      const privateInjector = createChild(childModules);\n      const getFromPrivateInjector = annotate(function(key) {\n        return privateInjector.get(key);\n      });\n\n      moduleExports.forEach(function(key) {\n        providers[key] = [ getFromPrivateInjector, key, 'private', privateInjector ];\n      });\n\n      // ensure child injector initializes\n      const initializers = (moduleDefinition.__init__ || []).slice();\n\n      initializers.unshift(function() {\n        privateInjector.init();\n      });\n\n      moduleDefinition = Object.assign({}, moduleDefinition, {\n        __init__: initializers\n      });\n\n      return createInitializer(moduleDefinition, privateInjector);\n    }\n\n    // normal module\n    Object.keys(moduleDefinition).forEach(function(key) {\n\n      if (key === '__init__' || key === '__depends__') {\n        return;\n      }\n\n      const typeDeclaration = /** @type { TypedDeclaration } */ (\n        moduleDefinition[key]\n      );\n\n      if (typeDeclaration[2] === 'private') {\n        providers[key] = typeDeclaration;\n        return;\n      }\n\n      const type = typeDeclaration[0];\n      const value = typeDeclaration[1];\n\n      providers[key] = [ factoryMap[type], arrayUnwrap(type, value), type ];\n    });\n\n    return createInitializer(moduleDefinition, self);\n  }\n\n  /**\n   * @param {ModuleDefinition[]} moduleDefinitions\n   * @param {ModuleDefinition} moduleDefinition\n   *\n   * @return {ModuleDefinition[]}\n   */\n  function resolveDependencies(moduleDefinitions, moduleDefinition) {\n\n    if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {\n      return moduleDefinitions;\n    }\n\n    moduleDefinitions = (moduleDefinition.__depends__ || []).reduce(resolveDependencies, moduleDefinitions);\n\n    if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {\n      return moduleDefinitions;\n    }\n\n    return moduleDefinitions.concat(moduleDefinition);\n  }\n\n  /**\n   * @param {ModuleDefinition[]} moduleDefinitions\n   *\n   * @return { () => void } initializerFn\n   */\n  function bootstrap(moduleDefinitions) {\n\n    const initializers = moduleDefinitions\n      .reduce(resolveDependencies, [])\n      .map(loadModule);\n\n    let initialized = false;\n\n    return function() {\n\n      if (initialized) {\n        return;\n      }\n\n      initialized = true;\n\n      initializers.forEach(initializer => initializer());\n    };\n  }\n\n  // public API\n  this.get = get;\n  this.invoke = invoke;\n  this.instantiate = instantiate;\n  this.createChild = createChild;\n\n  // setup\n  this.init = bootstrap(modules);\n}\n\n\n// helpers ///////////////\n\nfunction arrayUnwrap(type, value) {\n  if (type !== 'value' && isArray(value)) {\n    value = annotate(value.slice());\n  }\n\n  return value;\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRWdEO0FBQ2hEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2FtdW5kYS1tb2RlbGVyLWNsaWVudC8uLi9ub2RlX21vZHVsZXMvZGlkaS9kaXN0L2luZGV4LmpzPzBkNDUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQ0xBU1NfUEFUVEVSTiA9IC9eY2xhc3NbIHtdLztcblxuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNDbGFzcyhmbikge1xuICByZXR1cm4gQ0xBU1NfUEFUVEVSTi50ZXN0KGZuLnRvU3RyaW5nKCkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBvYmpcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBvYmpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaGFzT3duUHJvcChvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vaW5kZXguanMnKS5JbmplY3RBbm5vdGF0ZWQgfSBJbmplY3RBbm5vdGF0ZWRcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKlxuICogQHBhcmFtcyB7Wy4uLnN0cmluZ1tdLCBUXSB8IC4uLnN0cmluZ1tdLCBUfSBhcmdzXG4gKlxuICogQHJldHVybiB7VCAmIEluamVjdEFubm90YXRlZH1cbiAqL1xuZnVuY3Rpb24gYW5ub3RhdGUoLi4uYXJncykge1xuXG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgYXJncyA9IGFyZ3NbMF07XG4gIH1cblxuICBhcmdzID0gWyAuLi5hcmdzIF07XG5cbiAgY29uc3QgZm4gPSBhcmdzLnBvcCgpO1xuXG4gIGZuLiRpbmplY3QgPSBhcmdzO1xuXG4gIHJldHVybiBmbjtcbn1cblxuXG4vLyBDdXJyZW50IGxpbWl0YXRpb25zOlxuLy8gLSBjYW4ndCBwdXQgaW50byBcImZ1bmN0aW9uIGFyZ1wiIGNvbW1lbnRzXG4vLyBmdW5jdGlvbiAvKiAobm8gcGFyZW50aGVzaXMgbGlrZSB0aGlzKSAqLyAoKXt9XG4vLyBmdW5jdGlvbiBhYmMoIC8qIHh4IChubyBwYXJlbnRoZXNpcyBsaWtlIHRoaXMpICovIGEsIGIpIHt9XG4vL1xuLy8gSnVzdCBwdXQgdGhlIGNvbW1lbnQgYmVmb3JlIGZ1bmN0aW9uIG9yIGluc2lkZTpcbi8vIC8qICgoKHRoaXMgaXMgZmluZSkpKSAqLyBmdW5jdGlvbihhLCBiKSB7fVxuLy8gZnVuY3Rpb24gYWJjKGEpIHsgLyogKCgodGhpcyBpcyBmaW5lKSkpICovfVxuLy9cbi8vIC0gY2FuJ3QgcmVsaWFibHkgYXV0by1hbm5vdGF0ZSBjb25zdHJ1Y3Rvcjsgd2UnbGwgbWF0Y2ggdGhlXG4vLyBmaXJzdCBjb25zdHJ1Y3RvciguLi4pIHBhdHRlcm4gZm91bmQgd2hpY2ggbWF5IGJlIHRoZSBvbmVcbi8vIG9mIGEgbmVzdGVkIGNsYXNzLCB0b28uXG5cbmNvbnN0IENPTlNUUlVDVE9SX0FSR1MgPSAvY29uc3RydWN0b3JcXHMqW14oXSpcXChcXHMqKFteKV0qKVxcKS9tO1xuY29uc3QgRk5fQVJHUyA9IC9eKD86YXN5bmNcXHMrKT8oPzpmdW5jdGlvblxccypbXihdKik/KD86XFwoXFxzKihbXildKilcXCl8KFxcdyspKS9tO1xuY29uc3QgRk5fQVJHID0gL1xcL1xcKihbXipdKilcXCpcXC8vbTtcblxuLyoqXG4gKiBAcGFyYW0ge3Vua25vd259IGZuXG4gKlxuICogQHJldHVybiB7c3RyaW5nW119XG4gKi9cbmZ1bmN0aW9uIHBhcnNlQW5ub3RhdGlvbnMoZm4pIHtcblxuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgYW5ub3RhdGUgXCIke2ZufVwiLiBFeHBlY3RlZCBhIGZ1bmN0aW9uIWApO1xuICB9XG5cbiAgY29uc3QgbWF0Y2ggPSBmbi50b1N0cmluZygpLm1hdGNoKGlzQ2xhc3MoZm4pID8gQ09OU1RSVUNUT1JfQVJHUyA6IEZOX0FSR1MpO1xuXG4gIC8vIG1heSBwYXJzZSBjbGFzcyB3aXRob3V0IGNvbnN0cnVjdG9yXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBhcmdzID0gbWF0Y2hbMV0gfHwgbWF0Y2hbMl07XG5cbiAgcmV0dXJuIGFyZ3MgJiYgYXJncy5zcGxpdCgnLCcpLm1hcChhcmcgPT4ge1xuICAgIGNvbnN0IGFyZ01hdGNoID0gYXJnLm1hdGNoKEZOX0FSRyk7XG4gICAgcmV0dXJuIChhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXSB8fCBhcmcpLnRyaW0oKTtcbiAgfSkgfHwgW107XG59XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vaW5kZXguanMnKS5Nb2R1bGVEZWNsYXJhdGlvbiB9IE1vZHVsZURlY2xhcmF0aW9uXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9pbmRleC5qcycpLk1vZHVsZURlZmluaXRpb24gfSBNb2R1bGVEZWZpbml0aW9uXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9pbmRleC5qcycpLkluamVjdG9yQ29udGV4dCB9IEluamVjdG9yQ29udGV4dFxuICpcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2luZGV4LmpzJykuVHlwZWREZWNsYXJhdGlvbjxhbnksIGFueT4gfSBUeXBlZERlY2xhcmF0aW9uXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5qZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gbW9kdWxlcy5cbiAqXG4gKiBAcGFyYW0ge01vZHVsZURlZmluaXRpb25bXX0gbW9kdWxlc1xuICogQHBhcmFtIHtJbmplY3RvckNvbnRleHR9IFtfcGFyZW50XVxuICovXG5mdW5jdGlvbiBJbmplY3Rvcihtb2R1bGVzLCBfcGFyZW50KSB7XG5cbiAgY29uc3QgcGFyZW50ID0gX3BhcmVudCB8fCAvKiogQHR5cGUgSW5qZWN0b3JDb250ZXh0ICovICh7XG4gICAgZ2V0OiBmdW5jdGlvbihuYW1lLCBzdHJpY3QpIHtcbiAgICAgIGN1cnJlbnRseVJlc29sdmluZy5wdXNoKG5hbWUpO1xuXG4gICAgICBpZiAoc3RyaWN0ID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycm9yKGBObyBwcm92aWRlciBmb3IgXCIkeyBuYW1lIH1cIiFgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IGN1cnJlbnRseVJlc29sdmluZyA9IFtdO1xuICBjb25zdCBwcm92aWRlcnMgPSB0aGlzLl9wcm92aWRlcnMgPSBPYmplY3QuY3JlYXRlKHBhcmVudC5fcHJvdmlkZXJzIHx8IG51bGwpO1xuICBjb25zdCBpbnN0YW5jZXMgPSB0aGlzLl9pbnN0YW5jZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGNvbnN0IHNlbGYgPSBpbnN0YW5jZXMuaW5qZWN0b3IgPSB0aGlzO1xuXG4gIGNvbnN0IGVycm9yID0gZnVuY3Rpb24obXNnKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBjdXJyZW50bHlSZXNvbHZpbmcuam9pbignIC0+ICcpO1xuICAgIGN1cnJlbnRseVJlc29sdmluZy5sZW5ndGggPSAwO1xuICAgIHJldHVybiBuZXcgRXJyb3Ioc3RhY2sgPyBgJHsgbXNnIH0gKFJlc29sdmluZzogJHsgc3RhY2sgfSlgIDogbXNnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIGEgbmFtZWQgc2VydmljZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtib29sZWFufSBbc3RyaWN0PXRydWVdIGlmIGZhbHNlLCByZXNvbHZlIG1pc3Npbmcgc2VydmljZXMgdG8gbnVsbFxuICAgKlxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICBmdW5jdGlvbiBnZXQobmFtZSwgc3RyaWN0KSB7XG4gICAgaWYgKCFwcm92aWRlcnNbbmFtZV0gJiYgbmFtZS5pbmNsdWRlcygnLicpKSB7XG5cbiAgICAgIGNvbnN0IHBhcnRzID0gbmFtZS5zcGxpdCgnLicpO1xuICAgICAgbGV0IHBpdm90ID0gZ2V0KC8qKiBAdHlwZSB7IHN0cmluZyB9ICovIChwYXJ0cy5zaGlmdCgpKSk7XG5cbiAgICAgIHdoaWxlIChwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgcGl2b3QgPSBwaXZvdFsvKiogQHR5cGUgeyBzdHJpbmcgfSAqLyAocGFydHMuc2hpZnQoKSldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGl2b3Q7XG4gICAgfVxuXG4gICAgaWYgKGhhc093blByb3AoaW5zdGFuY2VzLCBuYW1lKSkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlc1tuYW1lXTtcbiAgICB9XG5cbiAgICBpZiAoaGFzT3duUHJvcChwcm92aWRlcnMsIG5hbWUpKSB7XG4gICAgICBpZiAoY3VycmVudGx5UmVzb2x2aW5nLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgIGN1cnJlbnRseVJlc29sdmluZy5wdXNoKG5hbWUpO1xuICAgICAgICB0aHJvdyBlcnJvcignQ2Fubm90IHJlc29sdmUgY2lyY3VsYXIgZGVwZW5kZW5jeSEnKTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudGx5UmVzb2x2aW5nLnB1c2gobmFtZSk7XG4gICAgICBpbnN0YW5jZXNbbmFtZV0gPSBwcm92aWRlcnNbbmFtZV1bMF0ocHJvdmlkZXJzW25hbWVdWzFdKTtcbiAgICAgIGN1cnJlbnRseVJlc29sdmluZy5wb3AoKTtcblxuICAgICAgcmV0dXJuIGluc3RhbmNlc1tuYW1lXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50LmdldChuYW1lLCBzdHJpY3QpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm5EZWYoZm4sIGxvY2Fscykge1xuXG4gICAgaWYgKHR5cGVvZiBsb2NhbHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBsb2NhbHMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoaXNBcnJheShmbikpIHtcbiAgICAgICAgZm4gPSBhbm5vdGF0ZShmbi5zbGljZSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycm9yKGBDYW5ub3QgaW52b2tlIFwiJHsgZm4gfVwiLiBFeHBlY3RlZCBhIGZ1bmN0aW9uIWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICBjb25zdCBpbmplY3QgPSBmbi4kaW5qZWN0IHx8IHBhcnNlQW5ub3RhdGlvbnMoZm4pO1xuICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IGluamVjdC5tYXAoZGVwID0+IHtcbiAgICAgIGlmIChoYXNPd25Qcm9wKGxvY2FscywgZGVwKSkge1xuICAgICAgICByZXR1cm4gbG9jYWxzW2RlcF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0KGRlcCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZm46IGZuLFxuICAgICAgZGVwZW5kZW5jaWVzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZSB0aGUgZ2l2ZW4gdHlwZSwgaW5qZWN0aW5nIGRlcGVuZGVuY2llcy5cbiAgICpcbiAgICogQHRlbXBsYXRlIFRcbiAgICpcbiAgICogQHBhcmFtIHsgRnVuY3Rpb24gfCBbLi4uc3RyaW5nW10sIEZ1bmN0aW9uIF19IHR5cGVcbiAgICpcbiAgICogQHJldHVybiBUXG4gICAqL1xuICBmdW5jdGlvbiBpbnN0YW50aWF0ZSh0eXBlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZm4sXG4gICAgICBkZXBlbmRlbmNpZXNcbiAgICB9ID0gZm5EZWYodHlwZSk7XG5cbiAgICAvLyBpbnN0YW50aWF0ZSB2YXIgYXJncyBjb25zdHJ1Y3RvclxuICAgIGNvbnN0IENvbnN0cnVjdG9yID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChmbiwgbnVsbCwgLi4uZGVwZW5kZW5jaWVzKTtcblxuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2UgdGhlIGdpdmVuIGZ1bmN0aW9uLCBpbmplY3RpbmcgZGVwZW5kZW5jaWVzLiBSZXR1cm4gdGhlIHJlc3VsdC5cbiAgICpcbiAgICogQHRlbXBsYXRlIFRcbiAgICpcbiAgICogQHBhcmFtIHsgRnVuY3Rpb24gfCBbLi4uc3RyaW5nW10sIEZ1bmN0aW9uIF19IGZ1bmNcbiAgICogQHBhcmFtIHsgT2JqZWN0IH0gW2NvbnRleHRdXG4gICAqIEBwYXJhbSB7IE9iamVjdCB9IFtsb2NhbHNdXG4gICAqXG4gICAqIEByZXR1cm4ge1R9IGludm9jYXRpb24gcmVzdWx0XG4gICAqL1xuICBmdW5jdGlvbiBpbnZva2UoZnVuYywgY29udGV4dCwgbG9jYWxzKSB7XG4gICAgY29uc3Qge1xuICAgICAgZm4sXG4gICAgICBkZXBlbmRlbmNpZXNcbiAgICB9ID0gZm5EZWYoZnVuYywgbG9jYWxzKTtcblxuICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBkZXBlbmRlbmNpZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SW5qZWN0b3J9IGNoaWxkSW5qZWN0b3JcbiAgICpcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVQcml2YXRlSW5qZWN0b3JGYWN0b3J5KGNoaWxkSW5qZWN0b3IpIHtcbiAgICByZXR1cm4gYW5ub3RhdGUoa2V5ID0+IGNoaWxkSW5qZWN0b3IuZ2V0KGtleSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TW9kdWxlRGVmaW5pdGlvbltdfSBtb2R1bGVzXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IFtmb3JjZU5ld0luc3RhbmNlc11cbiAgICpcbiAgICogQHJldHVybiB7SW5qZWN0b3J9XG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVDaGlsZChtb2R1bGVzLCBmb3JjZU5ld0luc3RhbmNlcykge1xuICAgIGlmIChmb3JjZU5ld0luc3RhbmNlcyAmJiBmb3JjZU5ld0luc3RhbmNlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGZyb21QYXJlbnRNb2R1bGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgY29uc3QgbWF0Y2hlZFNjb3BlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIGNvbnN0IHByaXZhdGVJbmplY3RvcnNDYWNoZSA9IFtdO1xuICAgICAgY29uc3QgcHJpdmF0ZUNoaWxkSW5qZWN0b3JzID0gW107XG4gICAgICBjb25zdCBwcml2YXRlQ2hpbGRGYWN0b3JpZXMgPSBbXTtcblxuICAgICAgbGV0IHByb3ZpZGVyO1xuICAgICAgbGV0IGNhY2hlSWR4O1xuICAgICAgbGV0IHByaXZhdGVDaGlsZEluamVjdG9yO1xuICAgICAgbGV0IHByaXZhdGVDaGlsZEluamVjdG9yRmFjdG9yeTtcblxuICAgICAgZm9yIChsZXQgbmFtZSBpbiBwcm92aWRlcnMpIHtcbiAgICAgICAgcHJvdmlkZXIgPSBwcm92aWRlcnNbbmFtZV07XG5cbiAgICAgICAgaWYgKGZvcmNlTmV3SW5zdGFuY2VzLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgaWYgKHByb3ZpZGVyWzJdID09PSAncHJpdmF0ZScpIHtcbiAgICAgICAgICAgIGNhY2hlSWR4ID0gcHJpdmF0ZUluamVjdG9yc0NhY2hlLmluZGV4T2YocHJvdmlkZXJbM10pO1xuICAgICAgICAgICAgaWYgKGNhY2hlSWR4ID09PSAtMSkge1xuICAgICAgICAgICAgICBwcml2YXRlQ2hpbGRJbmplY3RvciA9IHByb3ZpZGVyWzNdLmNyZWF0ZUNoaWxkKFtdLCBmb3JjZU5ld0luc3RhbmNlcyk7XG4gICAgICAgICAgICAgIHByaXZhdGVDaGlsZEluamVjdG9yRmFjdG9yeSA9IGNyZWF0ZVByaXZhdGVJbmplY3RvckZhY3RvcnkocHJpdmF0ZUNoaWxkSW5qZWN0b3IpO1xuICAgICAgICAgICAgICBwcml2YXRlSW5qZWN0b3JzQ2FjaGUucHVzaChwcm92aWRlclszXSk7XG4gICAgICAgICAgICAgIHByaXZhdGVDaGlsZEluamVjdG9ycy5wdXNoKHByaXZhdGVDaGlsZEluamVjdG9yKTtcbiAgICAgICAgICAgICAgcHJpdmF0ZUNoaWxkRmFjdG9yaWVzLnB1c2gocHJpdmF0ZUNoaWxkSW5qZWN0b3JGYWN0b3J5KTtcbiAgICAgICAgICAgICAgZnJvbVBhcmVudE1vZHVsZVtuYW1lXSA9IFsgcHJpdmF0ZUNoaWxkSW5qZWN0b3JGYWN0b3J5LCBuYW1lLCAncHJpdmF0ZScsIHByaXZhdGVDaGlsZEluamVjdG9yIF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tUGFyZW50TW9kdWxlW25hbWVdID0gWyBwcml2YXRlQ2hpbGRGYWN0b3JpZXNbY2FjaGVJZHhdLCBuYW1lLCAncHJpdmF0ZScsIHByaXZhdGVDaGlsZEluamVjdG9yc1tjYWNoZUlkeF0gXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJvbVBhcmVudE1vZHVsZVtuYW1lXSA9IFsgcHJvdmlkZXJbMl0sIHByb3ZpZGVyWzFdIF07XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hdGNoZWRTY29wZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChwcm92aWRlclsyXSA9PT0gJ2ZhY3RvcnknIHx8IHByb3ZpZGVyWzJdID09PSAndHlwZScpICYmIHByb3ZpZGVyWzFdLiRzY29wZSkge1xuICAgICAgICAgIC8qIGpzaGludCAtVzA4MyAqL1xuICAgICAgICAgIGZvcmNlTmV3SW5zdGFuY2VzLmZvckVhY2goc2NvcGUgPT4ge1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVyWzFdLiRzY29wZS5pbmRleE9mKHNjb3BlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgZnJvbVBhcmVudE1vZHVsZVtuYW1lXSA9IFsgcHJvdmlkZXJbMl0sIHByb3ZpZGVyWzFdIF07XG4gICAgICAgICAgICAgIG1hdGNoZWRTY29wZXNbc2NvcGVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3JjZU5ld0luc3RhbmNlcy5mb3JFYWNoKHNjb3BlID0+IHtcbiAgICAgICAgaWYgKCFtYXRjaGVkU2NvcGVzW3Njb3BlXSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcHJvdmlkZXIgZm9yIFwiJyArIHNjb3BlICsgJ1wiLiBDYW5ub3QgdXNlIHByb3ZpZGVyIGZyb20gdGhlIHBhcmVudCEnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIG1vZHVsZXMudW5zaGlmdChmcm9tUGFyZW50TW9kdWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEluamVjdG9yKG1vZHVsZXMsIHNlbGYpO1xuICB9XG5cbiAgY29uc3QgZmFjdG9yeU1hcCA9IHtcbiAgICBmYWN0b3J5OiBpbnZva2UsXG4gICAgdHlwZTogaW5zdGFudGlhdGUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge01vZHVsZURlZmluaXRpb259IG1vZHVsZURlZmluaXRpb25cbiAgICogQHBhcmFtIHtJbmplY3Rvcn0gaW5qZWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxpemVyKG1vZHVsZURlZmluaXRpb24sIGluamVjdG9yKSB7XG5cbiAgICBjb25zdCBpbml0aWFsaXplcnMgPSBtb2R1bGVEZWZpbml0aW9uLl9faW5pdF9fIHx8IFtdO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaW5pdGlhbGl6ZXJzLmZvckVhY2goaW5pdGlhbGl6ZXIgPT4ge1xuXG4gICAgICAgIC8vIGVhZ2VybHkgcmVzb2x2ZSBjb21wb25lbnQgKGZuIG9yIHN0cmluZylcbiAgICAgICAgaWYgKHR5cGVvZiBpbml0aWFsaXplciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpbmplY3Rvci5nZXQoaW5pdGlhbGl6ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluamVjdG9yLmludm9rZShpbml0aWFsaXplcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtNb2R1bGVEZWZpbml0aW9ufSBtb2R1bGVEZWZpbml0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBsb2FkTW9kdWxlKG1vZHVsZURlZmluaXRpb24pIHtcblxuICAgIGNvbnN0IG1vZHVsZUV4cG9ydHMgPSBtb2R1bGVEZWZpbml0aW9uLl9fZXhwb3J0c19fO1xuXG4gICAgLy8gcHJpdmF0ZSBtb2R1bGVcbiAgICBpZiAobW9kdWxlRXhwb3J0cykge1xuICAgICAgY29uc3QgbmVzdGVkTW9kdWxlcyA9IG1vZHVsZURlZmluaXRpb24uX19tb2R1bGVzX187XG5cbiAgICAgIGNvbnN0IGNsb25lZE1vZHVsZSA9IE9iamVjdC5rZXlzKG1vZHVsZURlZmluaXRpb24pLnJlZHVjZSgoY2xvbmVkTW9kdWxlLCBrZXkpID0+IHtcblxuICAgICAgICBpZiAoa2V5ICE9PSAnX19leHBvcnRzX18nICYmIGtleSAhPT0gJ19fbW9kdWxlc19fJyAmJiBrZXkgIT09ICdfX2luaXRfXycgJiYga2V5ICE9PSAnX19kZXBlbmRzX18nKSB7XG4gICAgICAgICAgY2xvbmVkTW9kdWxlW2tleV0gPSBtb2R1bGVEZWZpbml0aW9uW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xvbmVkTW9kdWxlO1xuICAgICAgfSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cbiAgICAgIGNvbnN0IGNoaWxkTW9kdWxlcyA9IChuZXN0ZWRNb2R1bGVzIHx8IFtdKS5jb25jYXQoY2xvbmVkTW9kdWxlKTtcblxuICAgICAgY29uc3QgcHJpdmF0ZUluamVjdG9yID0gY3JlYXRlQ2hpbGQoY2hpbGRNb2R1bGVzKTtcbiAgICAgIGNvbnN0IGdldEZyb21Qcml2YXRlSW5qZWN0b3IgPSBhbm5vdGF0ZShmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHByaXZhdGVJbmplY3Rvci5nZXQoa2V5KTtcbiAgICAgIH0pO1xuXG4gICAgICBtb2R1bGVFeHBvcnRzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHByb3ZpZGVyc1trZXldID0gWyBnZXRGcm9tUHJpdmF0ZUluamVjdG9yLCBrZXksICdwcml2YXRlJywgcHJpdmF0ZUluamVjdG9yIF07XG4gICAgICB9KTtcblxuICAgICAgLy8gZW5zdXJlIGNoaWxkIGluamVjdG9yIGluaXRpYWxpemVzXG4gICAgICBjb25zdCBpbml0aWFsaXplcnMgPSAobW9kdWxlRGVmaW5pdGlvbi5fX2luaXRfXyB8fCBbXSkuc2xpY2UoKTtcblxuICAgICAgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHByaXZhdGVJbmplY3Rvci5pbml0KCk7XG4gICAgICB9KTtcblxuICAgICAgbW9kdWxlRGVmaW5pdGlvbiA9IE9iamVjdC5hc3NpZ24oe30sIG1vZHVsZURlZmluaXRpb24sIHtcbiAgICAgICAgX19pbml0X186IGluaXRpYWxpemVyc1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBjcmVhdGVJbml0aWFsaXplcihtb2R1bGVEZWZpbml0aW9uLCBwcml2YXRlSW5qZWN0b3IpO1xuICAgIH1cblxuICAgIC8vIG5vcm1hbCBtb2R1bGVcbiAgICBPYmplY3Qua2V5cyhtb2R1bGVEZWZpbml0aW9uKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXG4gICAgICBpZiAoa2V5ID09PSAnX19pbml0X18nIHx8IGtleSA9PT0gJ19fZGVwZW5kc19fJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHR5cGVEZWNsYXJhdGlvbiA9IC8qKiBAdHlwZSB7IFR5cGVkRGVjbGFyYXRpb24gfSAqLyAoXG4gICAgICAgIG1vZHVsZURlZmluaXRpb25ba2V5XVxuICAgICAgKTtcblxuICAgICAgaWYgKHR5cGVEZWNsYXJhdGlvblsyXSA9PT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgIHByb3ZpZGVyc1trZXldID0gdHlwZURlY2xhcmF0aW9uO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHR5cGUgPSB0eXBlRGVjbGFyYXRpb25bMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IHR5cGVEZWNsYXJhdGlvblsxXTtcblxuICAgICAgcHJvdmlkZXJzW2tleV0gPSBbIGZhY3RvcnlNYXBbdHlwZV0sIGFycmF5VW53cmFwKHR5cGUsIHZhbHVlKSwgdHlwZSBdO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNyZWF0ZUluaXRpYWxpemVyKG1vZHVsZURlZmluaXRpb24sIHNlbGYpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TW9kdWxlRGVmaW5pdGlvbltdfSBtb2R1bGVEZWZpbml0aW9uc1xuICAgKiBAcGFyYW0ge01vZHVsZURlZmluaXRpb259IG1vZHVsZURlZmluaXRpb25cbiAgICpcbiAgICogQHJldHVybiB7TW9kdWxlRGVmaW5pdGlvbltdfVxuICAgKi9cbiAgZnVuY3Rpb24gcmVzb2x2ZURlcGVuZGVuY2llcyhtb2R1bGVEZWZpbml0aW9ucywgbW9kdWxlRGVmaW5pdGlvbikge1xuXG4gICAgaWYgKG1vZHVsZURlZmluaXRpb25zLmluZGV4T2YobW9kdWxlRGVmaW5pdGlvbikgIT09IC0xKSB7XG4gICAgICByZXR1cm4gbW9kdWxlRGVmaW5pdGlvbnM7XG4gICAgfVxuXG4gICAgbW9kdWxlRGVmaW5pdGlvbnMgPSAobW9kdWxlRGVmaW5pdGlvbi5fX2RlcGVuZHNfXyB8fCBbXSkucmVkdWNlKHJlc29sdmVEZXBlbmRlbmNpZXMsIG1vZHVsZURlZmluaXRpb25zKTtcblxuICAgIGlmIChtb2R1bGVEZWZpbml0aW9ucy5pbmRleE9mKG1vZHVsZURlZmluaXRpb24pICE9PSAtMSkge1xuICAgICAgcmV0dXJuIG1vZHVsZURlZmluaXRpb25zO1xuICAgIH1cblxuICAgIHJldHVybiBtb2R1bGVEZWZpbml0aW9ucy5jb25jYXQobW9kdWxlRGVmaW5pdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtNb2R1bGVEZWZpbml0aW9uW119IG1vZHVsZURlZmluaXRpb25zXG4gICAqXG4gICAqIEByZXR1cm4geyAoKSA9PiB2b2lkIH0gaW5pdGlhbGl6ZXJGblxuICAgKi9cbiAgZnVuY3Rpb24gYm9vdHN0cmFwKG1vZHVsZURlZmluaXRpb25zKSB7XG5cbiAgICBjb25zdCBpbml0aWFsaXplcnMgPSBtb2R1bGVEZWZpbml0aW9uc1xuICAgICAgLnJlZHVjZShyZXNvbHZlRGVwZW5kZW5jaWVzLCBbXSlcbiAgICAgIC5tYXAobG9hZE1vZHVsZSk7XG5cbiAgICBsZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcblxuICAgICAgaWYgKGluaXRpYWxpemVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgICBpbml0aWFsaXplcnMuZm9yRWFjaChpbml0aWFsaXplciA9PiBpbml0aWFsaXplcigpKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gcHVibGljIEFQSVxuICB0aGlzLmdldCA9IGdldDtcbiAgdGhpcy5pbnZva2UgPSBpbnZva2U7XG4gIHRoaXMuaW5zdGFudGlhdGUgPSBpbnN0YW50aWF0ZTtcbiAgdGhpcy5jcmVhdGVDaGlsZCA9IGNyZWF0ZUNoaWxkO1xuXG4gIC8vIHNldHVwXG4gIHRoaXMuaW5pdCA9IGJvb3RzdHJhcChtb2R1bGVzKTtcbn1cblxuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBhcnJheVVud3JhcCh0eXBlLCB2YWx1ZSkge1xuICBpZiAodHlwZSAhPT0gJ3ZhbHVlJyAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgIHZhbHVlID0gYW5ub3RhdGUodmFsdWUuc2xpY2UoKSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCB7IEluamVjdG9yLCBhbm5vdGF0ZSwgcGFyc2VBbm5vdGF0aW9ucyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/didi/dist/index.js\n\n}");

/***/ }

}]);