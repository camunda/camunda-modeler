"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkcamunda_modeler_client"] = self["webpackChunkcamunda_modeler_client"] || []).push([["vendors-node_modules_camunda_rpa-integration_node_modules_monaco-editor_esm_vs_basic-language-849fb3"],{

/***/ "../node_modules/@camunda/rpa-integration/node_modules/monaco-editor/esm/vs/basic-languages/elixir/elixir.js"
/*!*******************************************************************************************************************!*\
  !*** ../node_modules/@camunda/rpa-integration/node_modules/monaco-editor/esm/vs/basic-languages/elixir/elixir.js ***!
  \*******************************************************************************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   conf: () => (/* binding */ conf),\n/* harmony export */   language: () => (/* binding */ language)\n/* harmony export */ });\n/*!-----------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.51.0(67d664a32968e19e2eb08b696a92463804182ae4)\n * Released under the MIT license\n * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt\n *-----------------------------------------------------------------------------*/\n\n\n// src/basic-languages/elixir/elixir.ts\nvar conf = {\n  comments: {\n    lineComment: \"#\"\n  },\n  brackets: [\n    [\"{\", \"}\"],\n    [\"[\", \"]\"],\n    [\"(\", \")\"]\n  ],\n  surroundingPairs: [\n    { open: \"{\", close: \"}\" },\n    { open: \"[\", close: \"]\" },\n    { open: \"(\", close: \")\" },\n    { open: \"'\", close: \"'\" },\n    { open: '\"', close: '\"' }\n  ],\n  autoClosingPairs: [\n    { open: \"'\", close: \"'\", notIn: [\"string\", \"comment\"] },\n    { open: '\"', close: '\"', notIn: [\"comment\"] },\n    { open: '\"\"\"', close: '\"\"\"' },\n    { open: \"`\", close: \"`\", notIn: [\"string\", \"comment\"] },\n    { open: \"(\", close: \")\" },\n    { open: \"{\", close: \"}\" },\n    { open: \"[\", close: \"]\" },\n    { open: \"<<\", close: \">>\" }\n  ],\n  indentationRules: {\n    increaseIndentPattern: /^\\s*(after|else|catch|rescue|fn|[^#]*(do|<\\-|\\->|\\{|\\[|\\=))\\s*$/,\n    decreaseIndentPattern: /^\\s*((\\}|\\])\\s*$|(after|else|catch|rescue|end)\\b)/\n  }\n};\nvar language = {\n  defaultToken: \"source\",\n  tokenPostfix: \".elixir\",\n  brackets: [\n    { open: \"[\", close: \"]\", token: \"delimiter.square\" },\n    { open: \"(\", close: \")\", token: \"delimiter.parenthesis\" },\n    { open: \"{\", close: \"}\", token: \"delimiter.curly\" },\n    { open: \"<<\", close: \">>\", token: \"delimiter.angle.special\" }\n  ],\n  // Below are lists/regexps to which we reference later.\n  declarationKeywords: [\n    \"def\",\n    \"defp\",\n    \"defn\",\n    \"defnp\",\n    \"defguard\",\n    \"defguardp\",\n    \"defmacro\",\n    \"defmacrop\",\n    \"defdelegate\",\n    \"defcallback\",\n    \"defmacrocallback\",\n    \"defmodule\",\n    \"defprotocol\",\n    \"defexception\",\n    \"defimpl\",\n    \"defstruct\"\n  ],\n  operatorKeywords: [\"and\", \"in\", \"not\", \"or\", \"when\"],\n  namespaceKeywords: [\"alias\", \"import\", \"require\", \"use\"],\n  otherKeywords: [\n    \"after\",\n    \"case\",\n    \"catch\",\n    \"cond\",\n    \"do\",\n    \"else\",\n    \"end\",\n    \"fn\",\n    \"for\",\n    \"if\",\n    \"quote\",\n    \"raise\",\n    \"receive\",\n    \"rescue\",\n    \"super\",\n    \"throw\",\n    \"try\",\n    \"unless\",\n    \"unquote_splicing\",\n    \"unquote\",\n    \"with\"\n  ],\n  constants: [\"true\", \"false\", \"nil\"],\n  nameBuiltin: [\"__MODULE__\", \"__DIR__\", \"__ENV__\", \"__CALLER__\", \"__STACKTRACE__\"],\n  // Matches any of the operator names:\n  // <<< >>> ||| &&& ^^^ ~~~ === !== ~>> <~> |~> <|> == != <= >= && || \\\\ <> ++ -- |> =~ -> <- ~> <~ :: .. = < > + - * / | . ^ & !\n  operator: /-[->]?|!={0,2}|\\*{1,2}|\\/|\\\\\\\\|&{1,3}|\\.\\.?|\\^(?:\\^\\^)?|\\+\\+?|<(?:-|<<|=|>|\\|>|~>?)?|=~|={1,3}|>(?:=|>>)?|\\|~>|\\|>|\\|{1,3}|~>>?|~~~|::/,\n  // See https://hexdocs.pm/elixir/syntax-reference.html#variables\n  variableName: /[a-z_][a-zA-Z0-9_]*[?!]?/,\n  // See https://hexdocs.pm/elixir/syntax-reference.html#atoms\n  atomName: /[a-zA-Z_][a-zA-Z0-9_@]*[?!]?|@specialAtomName|@operator/,\n  specialAtomName: /\\.\\.\\.|<<>>|%\\{\\}|%|\\{\\}/,\n  aliasPart: /[A-Z][a-zA-Z0-9_]*/,\n  moduleName: /@aliasPart(?:\\.@aliasPart)*/,\n  // Sigil pairs are: \"\"\" \"\"\", ''' ''', \" \", ' ', / /, | |, < >, { }, [ ], ( )\n  sigilSymmetricDelimiter: /\"\"\"|'''|\"|'|\\/|\\|/,\n  sigilStartDelimiter: /@sigilSymmetricDelimiter|<|\\{|\\[|\\(/,\n  sigilEndDelimiter: /@sigilSymmetricDelimiter|>|\\}|\\]|\\)/,\n  sigilModifiers: /[a-zA-Z0-9]*/,\n  decimal: /\\d(?:_?\\d)*/,\n  hex: /[0-9a-fA-F](_?[0-9a-fA-F])*/,\n  octal: /[0-7](_?[0-7])*/,\n  binary: /[01](_?[01])*/,\n  // See https://hexdocs.pm/elixir/master/String.html#module-escape-characters\n  escape: /\\\\u[0-9a-fA-F]{4}|\\\\x[0-9a-fA-F]{2}|\\\\./,\n  // The keys below correspond to tokenizer states.\n  // We start from the root state and match against its rules\n  // until we explicitly transition into another state.\n  // The `include` simply brings in all operations from the given state\n  // and is useful for improving readability.\n  tokenizer: {\n    root: [\n      { include: \"@whitespace\" },\n      { include: \"@comments\" },\n      // Keywords start as either an identifier or a string,\n      // but end with a : so it's important to match this first.\n      { include: \"@keywordsShorthand\" },\n      { include: \"@numbers\" },\n      { include: \"@identifiers\" },\n      { include: \"@strings\" },\n      { include: \"@atoms\" },\n      { include: \"@sigils\" },\n      { include: \"@attributes\" },\n      { include: \"@symbols\" }\n    ],\n    // Whitespace\n    whitespace: [[/\\s+/, \"white\"]],\n    // Comments\n    comments: [[/(#)(.*)/, [\"comment.punctuation\", \"comment\"]]],\n    // Keyword list shorthand\n    keywordsShorthand: [\n      [/(@atomName)(:)(\\s+)/, [\"constant\", \"constant.punctuation\", \"white\"]],\n      // Use positive look-ahead to ensure the string is followed by :\n      // and should be considered a keyword.\n      [\n        /\"(?=([^\"]|#\\{.*?\\}|\\\\\")*\":)/,\n        { token: \"constant.delimiter\", next: \"@doubleQuotedStringKeyword\" }\n      ],\n      [\n        /'(?=([^']|#\\{.*?\\}|\\\\')*':)/,\n        { token: \"constant.delimiter\", next: \"@singleQuotedStringKeyword\" }\n      ]\n    ],\n    doubleQuotedStringKeyword: [\n      [/\":/, { token: \"constant.delimiter\", next: \"@pop\" }],\n      { include: \"@stringConstantContentInterpol\" }\n    ],\n    singleQuotedStringKeyword: [\n      [/':/, { token: \"constant.delimiter\", next: \"@pop\" }],\n      { include: \"@stringConstantContentInterpol\" }\n    ],\n    // Numbers\n    numbers: [\n      [/0b@binary/, \"number.binary\"],\n      [/0o@octal/, \"number.octal\"],\n      [/0x@hex/, \"number.hex\"],\n      [/@decimal\\.@decimal([eE]-?@decimal)?/, \"number.float\"],\n      [/@decimal/, \"number\"]\n    ],\n    // Identifiers\n    identifiers: [\n      // Tokenize identifier name in function-like definitions.\n      // Note: given `def a + b, do: nil`, `a` is not a function name,\n      // so we use negative look-ahead to ensure there's no operator.\n      [\n        /\\b(defp?|defnp?|defmacrop?|defguardp?|defdelegate)(\\s+)(@variableName)(?!\\s+@operator)/,\n        [\n          \"keyword.declaration\",\n          \"white\",\n          {\n            cases: {\n              unquote: \"keyword\",\n              \"@default\": \"function\"\n            }\n          }\n        ]\n      ],\n      // Tokenize function calls\n      [\n        // In-scope call - an identifier followed by ( or .(\n        /(@variableName)(?=\\s*\\.?\\s*\\()/,\n        {\n          cases: {\n            // Tokenize as keyword in cases like `if(..., do: ..., else: ...)`\n            \"@declarationKeywords\": \"keyword.declaration\",\n            \"@namespaceKeywords\": \"keyword\",\n            \"@otherKeywords\": \"keyword\",\n            \"@default\": \"function.call\"\n          }\n        }\n      ],\n      [\n        // Referencing function in a module\n        /(@moduleName)(\\s*)(\\.)(\\s*)(@variableName)/,\n        [\"type.identifier\", \"white\", \"operator\", \"white\", \"function.call\"]\n      ],\n      [\n        // Referencing function in an Erlang module\n        /(:)(@atomName)(\\s*)(\\.)(\\s*)(@variableName)/,\n        [\"constant.punctuation\", \"constant\", \"white\", \"operator\", \"white\", \"function.call\"]\n      ],\n      [\n        // Piping into a function (tokenized separately as it may not have parentheses)\n        /(\\|>)(\\s*)(@variableName)/,\n        [\n          \"operator\",\n          \"white\",\n          {\n            cases: {\n              \"@otherKeywords\": \"keyword\",\n              \"@default\": \"function.call\"\n            }\n          }\n        ]\n      ],\n      [\n        // Function reference passed to another function\n        /(&)(\\s*)(@variableName)/,\n        [\"operator\", \"white\", \"function.call\"]\n      ],\n      // Language keywords, builtins, constants and variables\n      [\n        /@variableName/,\n        {\n          cases: {\n            \"@declarationKeywords\": \"keyword.declaration\",\n            \"@operatorKeywords\": \"keyword.operator\",\n            \"@namespaceKeywords\": \"keyword\",\n            \"@otherKeywords\": \"keyword\",\n            \"@constants\": \"constant.language\",\n            \"@nameBuiltin\": \"variable.language\",\n            \"_.*\": \"comment.unused\",\n            \"@default\": \"identifier\"\n          }\n        }\n      ],\n      // Module names\n      [/@moduleName/, \"type.identifier\"]\n    ],\n    // Strings\n    strings: [\n      [/\"\"\"/, { token: \"string.delimiter\", next: \"@doubleQuotedHeredoc\" }],\n      [/'''/, { token: \"string.delimiter\", next: \"@singleQuotedHeredoc\" }],\n      [/\"/, { token: \"string.delimiter\", next: \"@doubleQuotedString\" }],\n      [/'/, { token: \"string.delimiter\", next: \"@singleQuotedString\" }]\n    ],\n    doubleQuotedHeredoc: [\n      [/\"\"\"/, { token: \"string.delimiter\", next: \"@pop\" }],\n      { include: \"@stringContentInterpol\" }\n    ],\n    singleQuotedHeredoc: [\n      [/'''/, { token: \"string.delimiter\", next: \"@pop\" }],\n      { include: \"@stringContentInterpol\" }\n    ],\n    doubleQuotedString: [\n      [/\"/, { token: \"string.delimiter\", next: \"@pop\" }],\n      { include: \"@stringContentInterpol\" }\n    ],\n    singleQuotedString: [\n      [/'/, { token: \"string.delimiter\", next: \"@pop\" }],\n      { include: \"@stringContentInterpol\" }\n    ],\n    // Atoms\n    atoms: [\n      [/(:)(@atomName)/, [\"constant.punctuation\", \"constant\"]],\n      [/:\"/, { token: \"constant.delimiter\", next: \"@doubleQuotedStringAtom\" }],\n      [/:'/, { token: \"constant.delimiter\", next: \"@singleQuotedStringAtom\" }]\n    ],\n    doubleQuotedStringAtom: [\n      [/\"/, { token: \"constant.delimiter\", next: \"@pop\" }],\n      { include: \"@stringConstantContentInterpol\" }\n    ],\n    singleQuotedStringAtom: [\n      [/'/, { token: \"constant.delimiter\", next: \"@pop\" }],\n      { include: \"@stringConstantContentInterpol\" }\n    ],\n    // Sigils\n    // See https://elixir-lang.org/getting-started/sigils.html\n    // Sigils allow for typing values using their textual representation.\n    // All sigils start with ~ followed by a letter or\n    // multi-letter uppercase starting at Elixir v1.15.0, indicating sigil type\n    // and then a delimiter pair enclosing the textual representation.\n    // Optional modifiers are allowed after the closing delimiter.\n    // For instance a regular expressions can be written as:\n    // ~r/foo|bar/ ~r{foo|bar} ~r/foo|bar/g\n    //\n    // In general lowercase sigils allow for interpolation\n    // and escaped characters, whereas uppercase sigils don't\n    //\n    // During tokenization we want to distinguish some\n    // specific sigil types, namely string and regexp,\n    // so that they cen be themed separately.\n    //\n    // To reasonably handle all those combinations we leverage\n    // dot-separated states, so if we transition to @sigilStart.interpol.s.{.}\n    // then \"sigilStart.interpol.s\" state will match and also all\n    // the individual dot-separated parameters can be accessed.\n    sigils: [\n      [/~[a-z]@sigilStartDelimiter/, { token: \"@rematch\", next: \"@sigil.interpol\" }],\n      [/~([A-Z]+)@sigilStartDelimiter/, { token: \"@rematch\", next: \"@sigil.noInterpol\" }]\n    ],\n    sigil: [\n      [/~([a-z]|[A-Z]+)\\{/, { token: \"@rematch\", switchTo: \"@sigilStart.$S2.$1.{.}\" }],\n      [/~([a-z]|[A-Z]+)\\[/, { token: \"@rematch\", switchTo: \"@sigilStart.$S2.$1.[.]\" }],\n      [/~([a-z]|[A-Z]+)\\(/, { token: \"@rematch\", switchTo: \"@sigilStart.$S2.$1.(.)\" }],\n      [/~([a-z]|[A-Z]+)\\</, { token: \"@rematch\", switchTo: \"@sigilStart.$S2.$1.<.>\" }],\n      [\n        /~([a-z]|[A-Z]+)(@sigilSymmetricDelimiter)/,\n        { token: \"@rematch\", switchTo: \"@sigilStart.$S2.$1.$2.$2\" }\n      ]\n    ],\n    // The definitions below expect states to be of the form:\n    //\n    // sigilStart.<interpol-or-noInterpol>.<sigil-letter>.<start-delimiter>.<end-delimiter>\n    // sigilContinue.<interpol-or-noInterpol>.<sigil-letter>.<start-delimiter>.<end-delimiter>\n    //\n    // The sigilStart state is used only to properly classify the token (as string/regex/sigil)\n    // and immediately switches to the sigilContinue sate, which handles the actual content\n    // and waits for the corresponding end delimiter.\n    \"sigilStart.interpol.s\": [\n      [\n        /~s@sigilStartDelimiter/,\n        {\n          token: \"string.delimiter\",\n          switchTo: \"@sigilContinue.$S2.$S3.$S4.$S5\"\n        }\n      ]\n    ],\n    \"sigilContinue.interpol.s\": [\n      [\n        /(@sigilEndDelimiter)@sigilModifiers/,\n        {\n          cases: {\n            \"$1==$S5\": { token: \"string.delimiter\", next: \"@pop\" },\n            \"@default\": \"string\"\n          }\n        }\n      ],\n      { include: \"@stringContentInterpol\" }\n    ],\n    \"sigilStart.noInterpol.S\": [\n      [\n        /~S@sigilStartDelimiter/,\n        {\n          token: \"string.delimiter\",\n          switchTo: \"@sigilContinue.$S2.$S3.$S4.$S5\"\n        }\n      ]\n    ],\n    \"sigilContinue.noInterpol.S\": [\n      // Ignore escaped sigil end\n      [/(^|[^\\\\])\\\\@sigilEndDelimiter/, \"string\"],\n      [\n        /(@sigilEndDelimiter)@sigilModifiers/,\n        {\n          cases: {\n            \"$1==$S5\": { token: \"string.delimiter\", next: \"@pop\" },\n            \"@default\": \"string\"\n          }\n        }\n      ],\n      { include: \"@stringContent\" }\n    ],\n    \"sigilStart.interpol.r\": [\n      [\n        /~r@sigilStartDelimiter/,\n        {\n          token: \"regexp.delimiter\",\n          switchTo: \"@sigilContinue.$S2.$S3.$S4.$S5\"\n        }\n      ]\n    ],\n    \"sigilContinue.interpol.r\": [\n      [\n        /(@sigilEndDelimiter)@sigilModifiers/,\n        {\n          cases: {\n            \"$1==$S5\": { token: \"regexp.delimiter\", next: \"@pop\" },\n            \"@default\": \"regexp\"\n          }\n        }\n      ],\n      { include: \"@regexpContentInterpol\" }\n    ],\n    \"sigilStart.noInterpol.R\": [\n      [\n        /~R@sigilStartDelimiter/,\n        {\n          token: \"regexp.delimiter\",\n          switchTo: \"@sigilContinue.$S2.$S3.$S4.$S5\"\n        }\n      ]\n    ],\n    \"sigilContinue.noInterpol.R\": [\n      // Ignore escaped sigil end\n      [/(^|[^\\\\])\\\\@sigilEndDelimiter/, \"regexp\"],\n      [\n        /(@sigilEndDelimiter)@sigilModifiers/,\n        {\n          cases: {\n            \"$1==$S5\": { token: \"regexp.delimiter\", next: \"@pop\" },\n            \"@default\": \"regexp\"\n          }\n        }\n      ],\n      { include: \"@regexpContent\" }\n    ],\n    // Fallback to the generic sigil by default\n    \"sigilStart.interpol\": [\n      [\n        /~([a-z]|[A-Z]+)@sigilStartDelimiter/,\n        {\n          token: \"sigil.delimiter\",\n          switchTo: \"@sigilContinue.$S2.$S3.$S4.$S5\"\n        }\n      ]\n    ],\n    \"sigilContinue.interpol\": [\n      [\n        /(@sigilEndDelimiter)@sigilModifiers/,\n        {\n          cases: {\n            \"$1==$S5\": { token: \"sigil.delimiter\", next: \"@pop\" },\n            \"@default\": \"sigil\"\n          }\n        }\n      ],\n      { include: \"@sigilContentInterpol\" }\n    ],\n    \"sigilStart.noInterpol\": [\n      [\n        /~([a-z]|[A-Z]+)@sigilStartDelimiter/,\n        {\n          token: \"sigil.delimiter\",\n          switchTo: \"@sigilContinue.$S2.$S3.$S4.$S5\"\n        }\n      ]\n    ],\n    \"sigilContinue.noInterpol\": [\n      // Ignore escaped sigil end\n      [/(^|[^\\\\])\\\\@sigilEndDelimiter/, \"sigil\"],\n      [\n        /(@sigilEndDelimiter)@sigilModifiers/,\n        {\n          cases: {\n            \"$1==$S5\": { token: \"sigil.delimiter\", next: \"@pop\" },\n            \"@default\": \"sigil\"\n          }\n        }\n      ],\n      { include: \"@sigilContent\" }\n    ],\n    // Attributes\n    attributes: [\n      // Module @doc* attributes - tokenized as comments\n      [\n        /\\@(module|type)?doc (~[sS])?\"\"\"/,\n        {\n          token: \"comment.block.documentation\",\n          next: \"@doubleQuotedHeredocDocstring\"\n        }\n      ],\n      [\n        /\\@(module|type)?doc (~[sS])?'''/,\n        {\n          token: \"comment.block.documentation\",\n          next: \"@singleQuotedHeredocDocstring\"\n        }\n      ],\n      [\n        /\\@(module|type)?doc (~[sS])?\"/,\n        {\n          token: \"comment.block.documentation\",\n          next: \"@doubleQuotedStringDocstring\"\n        }\n      ],\n      [\n        /\\@(module|type)?doc (~[sS])?'/,\n        {\n          token: \"comment.block.documentation\",\n          next: \"@singleQuotedStringDocstring\"\n        }\n      ],\n      [/\\@(module|type)?doc false/, \"comment.block.documentation\"],\n      // Module attributes\n      [/\\@(@variableName)/, \"variable\"]\n    ],\n    doubleQuotedHeredocDocstring: [\n      [/\"\"\"/, { token: \"comment.block.documentation\", next: \"@pop\" }],\n      { include: \"@docstringContent\" }\n    ],\n    singleQuotedHeredocDocstring: [\n      [/'''/, { token: \"comment.block.documentation\", next: \"@pop\" }],\n      { include: \"@docstringContent\" }\n    ],\n    doubleQuotedStringDocstring: [\n      [/\"/, { token: \"comment.block.documentation\", next: \"@pop\" }],\n      { include: \"@docstringContent\" }\n    ],\n    singleQuotedStringDocstring: [\n      [/'/, { token: \"comment.block.documentation\", next: \"@pop\" }],\n      { include: \"@docstringContent\" }\n    ],\n    // Operators, punctuation, brackets\n    symbols: [\n      // Code point operator (either with regular character ?a or an escaped one ?\\n)\n      [/\\?(\\\\.|[^\\\\\\s])/, \"number.constant\"],\n      // Anonymous function arguments\n      [/&\\d+/, \"operator\"],\n      // Bitshift operators (must go before delimiters, so that << >> don't match first)\n      [/<<<|>>>/, \"operator\"],\n      // Delimiter pairs\n      [/[()\\[\\]\\{\\}]|<<|>>/, \"@brackets\"],\n      // Triple dot is a valid name (must go before operators, so that .. doesn't match instead)\n      [/\\.\\.\\./, \"identifier\"],\n      // Punctuation => (must go before operators, so it's not tokenized as = then >)\n      [/=>/, \"punctuation\"],\n      // Operators\n      [/@operator/, \"operator\"],\n      // Punctuation\n      [/[:;,.%]/, \"punctuation\"]\n    ],\n    // Generic helpers\n    stringContentInterpol: [\n      { include: \"@interpolation\" },\n      { include: \"@escapeChar\" },\n      { include: \"@stringContent\" }\n    ],\n    stringContent: [[/./, \"string\"]],\n    stringConstantContentInterpol: [\n      { include: \"@interpolation\" },\n      { include: \"@escapeChar\" },\n      { include: \"@stringConstantContent\" }\n    ],\n    stringConstantContent: [[/./, \"constant\"]],\n    regexpContentInterpol: [\n      { include: \"@interpolation\" },\n      { include: \"@escapeChar\" },\n      { include: \"@regexpContent\" }\n    ],\n    regexpContent: [\n      // # may be a regular regexp char, so we use a heuristic\n      // assuming a # surrounded by whitespace is actually a comment.\n      [/(\\s)(#)(\\s.*)$/, [\"white\", \"comment.punctuation\", \"comment\"]],\n      [/./, \"regexp\"]\n    ],\n    sigilContentInterpol: [\n      { include: \"@interpolation\" },\n      { include: \"@escapeChar\" },\n      { include: \"@sigilContent\" }\n    ],\n    sigilContent: [[/./, \"sigil\"]],\n    docstringContent: [[/./, \"comment.block.documentation\"]],\n    escapeChar: [[/@escape/, \"constant.character.escape\"]],\n    interpolation: [[/#{/, { token: \"delimiter.bracket.embed\", next: \"@interpolationContinue\" }]],\n    interpolationContinue: [\n      [/}/, { token: \"delimiter.bracket.embed\", next: \"@pop\" }],\n      // Interpolation brackets may contain arbitrary code,\n      // so we simply match against all the root rules,\n      // until we reach interpolation end (the above matches).\n      { include: \"@root\" }\n    ]\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BjYW11bmRhL3JwYS1pbnRlZ3JhdGlvbi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzaWMtbGFuZ3VhZ2VzL2VsaXhpci9lbGl4aXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsT0FBTyxLQUFLO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFFBQVEsWUFBWSxHQUFHO0FBQzdCLE1BQU0sdUJBQXVCO0FBQzdCLE1BQU0sdUJBQXVCO0FBQzdCLE1BQU0sdUJBQXVCO0FBQzdCLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTSxxREFBcUQ7QUFDM0QsTUFBTSwyQ0FBMkM7QUFDakQsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSxxREFBcUQ7QUFDM0QsTUFBTSx1QkFBdUI7QUFDN0IsTUFBTSxRQUFRLFlBQVksR0FBRztBQUM3QixNQUFNLHVCQUF1QjtBQUM3QixNQUFNO0FBQ047QUFDQTtBQUNBLCtFQUErRTtBQUMvRSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrREFBa0Q7QUFDeEQsTUFBTSx1REFBdUQ7QUFDN0QsTUFBTSxRQUFRLFlBQVksNkJBQTZCO0FBQ3ZELE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixJQUFJLElBQUksSUFBSSxXQUFXLElBQUkscURBQXFELElBQUksd0JBQXdCLElBQUk7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsRUFBRSxLQUFLLEVBQUU7QUFDNUM7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBLHFEQUFxRDtBQUNyRCxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEVBQUUsZ0JBQWdCLEVBQUU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdCQUF3QjtBQUNoQyxRQUFRLHNCQUFzQjtBQUM5QjtBQUNBO0FBQ0EsUUFBUSwrQkFBK0I7QUFDdkMsUUFBUSxxQkFBcUI7QUFDN0IsUUFBUSx5QkFBeUI7QUFDakMsUUFBUSxxQkFBcUI7QUFDN0IsUUFBUSxtQkFBbUI7QUFDM0IsUUFBUSxvQkFBb0I7QUFDNUIsUUFBUSx3QkFBd0I7QUFDaEMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSztBQUMzQixVQUFVO0FBQ1Y7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJDQUEyQztBQUMxRCxRQUFRO0FBQ1I7QUFDQTtBQUNBLGVBQWUsMkNBQTJDO0FBQzFELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBeUQ7QUFDekUsZ0JBQWdCLHlEQUF5RDtBQUN6RSxjQUFjLHdEQUF3RDtBQUN0RSxjQUFjLHdEQUF3RDtBQUN0RTtBQUNBO0FBQ0EsZ0JBQWdCLHlDQUF5QztBQUN6RCxRQUFRO0FBQ1I7QUFDQTtBQUNBLGdCQUFnQix5Q0FBeUM7QUFDekQsUUFBUTtBQUNSO0FBQ0E7QUFDQSxjQUFjLHlDQUF5QztBQUN2RCxRQUFRO0FBQ1I7QUFDQTtBQUNBLGNBQWMseUNBQXlDO0FBQ3ZELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOERBQThEO0FBQzdFLGVBQWUsOERBQThEO0FBQzdFO0FBQ0E7QUFDQSxjQUFjLDJDQUEyQztBQUN6RCxRQUFRO0FBQ1I7QUFDQTtBQUNBLGNBQWMsMkNBQTJDO0FBQ3pELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDRDQUE0QztBQUNuRiwwQ0FBMEMsOENBQThDO0FBQ3hGO0FBQ0E7QUFDQSx5QkFBeUIsS0FBSyxrREFBa0QsRUFBRSxHQUFHO0FBQ3JGLDhCQUE4Qix1REFBdUQ7QUFDckYsOEJBQThCLHVEQUF1RDtBQUNyRiw4QkFBOEIsdURBQXVEO0FBQ3JGO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlDQUF5QztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlDQUF5QztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUNBQXlDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUNBQXlDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdDQUF3QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdDQUF3QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvREFBb0Q7QUFDcEUsUUFBUTtBQUNSO0FBQ0E7QUFDQSxnQkFBZ0Isb0RBQW9EO0FBQ3BFLFFBQVE7QUFDUjtBQUNBO0FBQ0EsY0FBYyxvREFBb0Q7QUFDbEUsUUFBUTtBQUNSO0FBQ0E7QUFDQSxjQUFjLG9EQUFvRDtBQUNsRSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsRUFBRTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJCQUEyQjtBQUNuQyxRQUFRLHdCQUF3QjtBQUNoQyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQkFBMkI7QUFDbkMsUUFBUSx3QkFBd0I7QUFDaEMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkJBQTJCO0FBQ25DLFFBQVEsd0JBQXdCO0FBQ2hDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQkFBMkI7QUFDbkMsUUFBUSx3QkFBd0I7QUFDaEMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQUssa0VBQWtFO0FBQy9GO0FBQ0EsU0FBUyxLQUFLLGdEQUFnRDtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBSUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYW11bmRhLW1vZGVsZXItY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9AY2FtdW5kYS9ycGEtaW50ZWdyYXRpb24vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2ljLWxhbmd1YWdlcy9lbGl4aXIvZWxpeGlyLmpzPzRlMjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyohLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVmVyc2lvbjogMC41MS4wKDY3ZDY2NGEzMjk2OGUxOWUyZWIwOGI2OTZhOTI0NjM4MDQxODJhZTQpXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvbW9uYWNvLWVkaXRvci9ibG9iL21haW4vTElDRU5TRS50eHRcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cbi8vIHNyYy9iYXNpYy1sYW5ndWFnZXMvZWxpeGlyL2VsaXhpci50c1xudmFyIGNvbmYgPSB7XG4gIGNvbW1lbnRzOiB7XG4gICAgbGluZUNvbW1lbnQ6IFwiI1wiXG4gIH0sXG4gIGJyYWNrZXRzOiBbXG4gICAgW1wie1wiLCBcIn1cIl0sXG4gICAgW1wiW1wiLCBcIl1cIl0sXG4gICAgW1wiKFwiLCBcIilcIl1cbiAgXSxcbiAgc3Vycm91bmRpbmdQYWlyczogW1xuICAgIHsgb3BlbjogXCJ7XCIsIGNsb3NlOiBcIn1cIiB9LFxuICAgIHsgb3BlbjogXCJbXCIsIGNsb3NlOiBcIl1cIiB9LFxuICAgIHsgb3BlbjogXCIoXCIsIGNsb3NlOiBcIilcIiB9LFxuICAgIHsgb3BlbjogXCInXCIsIGNsb3NlOiBcIidcIiB9LFxuICAgIHsgb3BlbjogJ1wiJywgY2xvc2U6ICdcIicgfVxuICBdLFxuICBhdXRvQ2xvc2luZ1BhaXJzOiBbXG4gICAgeyBvcGVuOiBcIidcIiwgY2xvc2U6IFwiJ1wiLCBub3RJbjogW1wic3RyaW5nXCIsIFwiY29tbWVudFwiXSB9LFxuICAgIHsgb3BlbjogJ1wiJywgY2xvc2U6ICdcIicsIG5vdEluOiBbXCJjb21tZW50XCJdIH0sXG4gICAgeyBvcGVuOiAnXCJcIlwiJywgY2xvc2U6ICdcIlwiXCInIH0sXG4gICAgeyBvcGVuOiBcImBcIiwgY2xvc2U6IFwiYFwiLCBub3RJbjogW1wic3RyaW5nXCIsIFwiY29tbWVudFwiXSB9LFxuICAgIHsgb3BlbjogXCIoXCIsIGNsb3NlOiBcIilcIiB9LFxuICAgIHsgb3BlbjogXCJ7XCIsIGNsb3NlOiBcIn1cIiB9LFxuICAgIHsgb3BlbjogXCJbXCIsIGNsb3NlOiBcIl1cIiB9LFxuICAgIHsgb3BlbjogXCI8PFwiLCBjbG9zZTogXCI+PlwiIH1cbiAgXSxcbiAgaW5kZW50YXRpb25SdWxlczoge1xuICAgIGluY3JlYXNlSW5kZW50UGF0dGVybjogL15cXHMqKGFmdGVyfGVsc2V8Y2F0Y2h8cmVzY3VlfGZufFteI10qKGRvfDxcXC18XFwtPnxcXHt8XFxbfFxcPSkpXFxzKiQvLFxuICAgIGRlY3JlYXNlSW5kZW50UGF0dGVybjogL15cXHMqKChcXH18XFxdKVxccyokfChhZnRlcnxlbHNlfGNhdGNofHJlc2N1ZXxlbmQpXFxiKS9cbiAgfVxufTtcbnZhciBsYW5ndWFnZSA9IHtcbiAgZGVmYXVsdFRva2VuOiBcInNvdXJjZVwiLFxuICB0b2tlblBvc3RmaXg6IFwiLmVsaXhpclwiLFxuICBicmFja2V0czogW1xuICAgIHsgb3BlbjogXCJbXCIsIGNsb3NlOiBcIl1cIiwgdG9rZW46IFwiZGVsaW1pdGVyLnNxdWFyZVwiIH0sXG4gICAgeyBvcGVuOiBcIihcIiwgY2xvc2U6IFwiKVwiLCB0b2tlbjogXCJkZWxpbWl0ZXIucGFyZW50aGVzaXNcIiB9LFxuICAgIHsgb3BlbjogXCJ7XCIsIGNsb3NlOiBcIn1cIiwgdG9rZW46IFwiZGVsaW1pdGVyLmN1cmx5XCIgfSxcbiAgICB7IG9wZW46IFwiPDxcIiwgY2xvc2U6IFwiPj5cIiwgdG9rZW46IFwiZGVsaW1pdGVyLmFuZ2xlLnNwZWNpYWxcIiB9XG4gIF0sXG4gIC8vIEJlbG93IGFyZSBsaXN0cy9yZWdleHBzIHRvIHdoaWNoIHdlIHJlZmVyZW5jZSBsYXRlci5cbiAgZGVjbGFyYXRpb25LZXl3b3JkczogW1xuICAgIFwiZGVmXCIsXG4gICAgXCJkZWZwXCIsXG4gICAgXCJkZWZuXCIsXG4gICAgXCJkZWZucFwiLFxuICAgIFwiZGVmZ3VhcmRcIixcbiAgICBcImRlZmd1YXJkcFwiLFxuICAgIFwiZGVmbWFjcm9cIixcbiAgICBcImRlZm1hY3JvcFwiLFxuICAgIFwiZGVmZGVsZWdhdGVcIixcbiAgICBcImRlZmNhbGxiYWNrXCIsXG4gICAgXCJkZWZtYWNyb2NhbGxiYWNrXCIsXG4gICAgXCJkZWZtb2R1bGVcIixcbiAgICBcImRlZnByb3RvY29sXCIsXG4gICAgXCJkZWZleGNlcHRpb25cIixcbiAgICBcImRlZmltcGxcIixcbiAgICBcImRlZnN0cnVjdFwiXG4gIF0sXG4gIG9wZXJhdG9yS2V5d29yZHM6IFtcImFuZFwiLCBcImluXCIsIFwibm90XCIsIFwib3JcIiwgXCJ3aGVuXCJdLFxuICBuYW1lc3BhY2VLZXl3b3JkczogW1wiYWxpYXNcIiwgXCJpbXBvcnRcIiwgXCJyZXF1aXJlXCIsIFwidXNlXCJdLFxuICBvdGhlcktleXdvcmRzOiBbXG4gICAgXCJhZnRlclwiLFxuICAgIFwiY2FzZVwiLFxuICAgIFwiY2F0Y2hcIixcbiAgICBcImNvbmRcIixcbiAgICBcImRvXCIsXG4gICAgXCJlbHNlXCIsXG4gICAgXCJlbmRcIixcbiAgICBcImZuXCIsXG4gICAgXCJmb3JcIixcbiAgICBcImlmXCIsXG4gICAgXCJxdW90ZVwiLFxuICAgIFwicmFpc2VcIixcbiAgICBcInJlY2VpdmVcIixcbiAgICBcInJlc2N1ZVwiLFxuICAgIFwic3VwZXJcIixcbiAgICBcInRocm93XCIsXG4gICAgXCJ0cnlcIixcbiAgICBcInVubGVzc1wiLFxuICAgIFwidW5xdW90ZV9zcGxpY2luZ1wiLFxuICAgIFwidW5xdW90ZVwiLFxuICAgIFwid2l0aFwiXG4gIF0sXG4gIGNvbnN0YW50czogW1widHJ1ZVwiLCBcImZhbHNlXCIsIFwibmlsXCJdLFxuICBuYW1lQnVpbHRpbjogW1wiX19NT0RVTEVfX1wiLCBcIl9fRElSX19cIiwgXCJfX0VOVl9fXCIsIFwiX19DQUxMRVJfX1wiLCBcIl9fU1RBQ0tUUkFDRV9fXCJdLFxuICAvLyBNYXRjaGVzIGFueSBvZiB0aGUgb3BlcmF0b3IgbmFtZXM6XG4gIC8vIDw8PCA+Pj4gfHx8ICYmJiBeXl4gfn5+ID09PSAhPT0gfj4+IDx+PiB8fj4gPHw+ID09ICE9IDw9ID49ICYmIHx8IFxcXFwgPD4gKysgLS0gfD4gPX4gLT4gPC0gfj4gPH4gOjogLi4gPSA8ID4gKyAtICogLyB8IC4gXiAmICFcbiAgb3BlcmF0b3I6IC8tWy0+XT98IT17MCwyfXxcXCp7MSwyfXxcXC98XFxcXFxcXFx8JnsxLDN9fFxcLlxcLj98XFxeKD86XFxeXFxeKT98XFwrXFwrP3w8KD86LXw8PHw9fD58XFx8Pnx+Pj8pP3w9fnw9ezEsM318Pig/Oj18Pj4pP3xcXHx+PnxcXHw+fFxcfHsxLDN9fH4+Pj98fn5+fDo6LyxcbiAgLy8gU2VlIGh0dHBzOi8vaGV4ZG9jcy5wbS9lbGl4aXIvc3ludGF4LXJlZmVyZW5jZS5odG1sI3ZhcmlhYmxlc1xuICB2YXJpYWJsZU5hbWU6IC9bYS16X11bYS16QS1aMC05X10qWz8hXT8vLFxuICAvLyBTZWUgaHR0cHM6Ly9oZXhkb2NzLnBtL2VsaXhpci9zeW50YXgtcmVmZXJlbmNlLmh0bWwjYXRvbXNcbiAgYXRvbU5hbWU6IC9bYS16QS1aX11bYS16QS1aMC05X0BdKls/IV0/fEBzcGVjaWFsQXRvbU5hbWV8QG9wZXJhdG9yLyxcbiAgc3BlY2lhbEF0b21OYW1lOiAvXFwuXFwuXFwufDw8Pj58JVxce1xcfXwlfFxce1xcfS8sXG4gIGFsaWFzUGFydDogL1tBLVpdW2EtekEtWjAtOV9dKi8sXG4gIG1vZHVsZU5hbWU6IC9AYWxpYXNQYXJ0KD86XFwuQGFsaWFzUGFydCkqLyxcbiAgLy8gU2lnaWwgcGFpcnMgYXJlOiBcIlwiXCIgXCJcIlwiLCAnJycgJycnLCBcIiBcIiwgJyAnLCAvIC8sIHwgfCwgPCA+LCB7IH0sIFsgXSwgKCApXG4gIHNpZ2lsU3ltbWV0cmljRGVsaW1pdGVyOiAvXCJcIlwifCcnJ3xcInwnfFxcL3xcXHwvLFxuICBzaWdpbFN0YXJ0RGVsaW1pdGVyOiAvQHNpZ2lsU3ltbWV0cmljRGVsaW1pdGVyfDx8XFx7fFxcW3xcXCgvLFxuICBzaWdpbEVuZERlbGltaXRlcjogL0BzaWdpbFN5bW1ldHJpY0RlbGltaXRlcnw+fFxcfXxcXF18XFwpLyxcbiAgc2lnaWxNb2RpZmllcnM6IC9bYS16QS1aMC05XSovLFxuICBkZWNpbWFsOiAvXFxkKD86Xz9cXGQpKi8sXG4gIGhleDogL1swLTlhLWZBLUZdKF8/WzAtOWEtZkEtRl0pKi8sXG4gIG9jdGFsOiAvWzAtN10oXz9bMC03XSkqLyxcbiAgYmluYXJ5OiAvWzAxXShfP1swMV0pKi8sXG4gIC8vIFNlZSBodHRwczovL2hleGRvY3MucG0vZWxpeGlyL21hc3Rlci9TdHJpbmcuaHRtbCNtb2R1bGUtZXNjYXBlLWNoYXJhY3RlcnNcbiAgZXNjYXBlOiAvXFxcXHVbMC05YS1mQS1GXXs0fXxcXFxceFswLTlhLWZBLUZdezJ9fFxcXFwuLyxcbiAgLy8gVGhlIGtleXMgYmVsb3cgY29ycmVzcG9uZCB0byB0b2tlbml6ZXIgc3RhdGVzLlxuICAvLyBXZSBzdGFydCBmcm9tIHRoZSByb290IHN0YXRlIGFuZCBtYXRjaCBhZ2FpbnN0IGl0cyBydWxlc1xuICAvLyB1bnRpbCB3ZSBleHBsaWNpdGx5IHRyYW5zaXRpb24gaW50byBhbm90aGVyIHN0YXRlLlxuICAvLyBUaGUgYGluY2x1ZGVgIHNpbXBseSBicmluZ3MgaW4gYWxsIG9wZXJhdGlvbnMgZnJvbSB0aGUgZ2l2ZW4gc3RhdGVcbiAgLy8gYW5kIGlzIHVzZWZ1bCBmb3IgaW1wcm92aW5nIHJlYWRhYmlsaXR5LlxuICB0b2tlbml6ZXI6IHtcbiAgICByb290OiBbXG4gICAgICB7IGluY2x1ZGU6IFwiQHdoaXRlc3BhY2VcIiB9LFxuICAgICAgeyBpbmNsdWRlOiBcIkBjb21tZW50c1wiIH0sXG4gICAgICAvLyBLZXl3b3JkcyBzdGFydCBhcyBlaXRoZXIgYW4gaWRlbnRpZmllciBvciBhIHN0cmluZyxcbiAgICAgIC8vIGJ1dCBlbmQgd2l0aCBhIDogc28gaXQncyBpbXBvcnRhbnQgdG8gbWF0Y2ggdGhpcyBmaXJzdC5cbiAgICAgIHsgaW5jbHVkZTogXCJAa2V5d29yZHNTaG9ydGhhbmRcIiB9LFxuICAgICAgeyBpbmNsdWRlOiBcIkBudW1iZXJzXCIgfSxcbiAgICAgIHsgaW5jbHVkZTogXCJAaWRlbnRpZmllcnNcIiB9LFxuICAgICAgeyBpbmNsdWRlOiBcIkBzdHJpbmdzXCIgfSxcbiAgICAgIHsgaW5jbHVkZTogXCJAYXRvbXNcIiB9LFxuICAgICAgeyBpbmNsdWRlOiBcIkBzaWdpbHNcIiB9LFxuICAgICAgeyBpbmNsdWRlOiBcIkBhdHRyaWJ1dGVzXCIgfSxcbiAgICAgIHsgaW5jbHVkZTogXCJAc3ltYm9sc1wiIH1cbiAgICBdLFxuICAgIC8vIFdoaXRlc3BhY2VcbiAgICB3aGl0ZXNwYWNlOiBbWy9cXHMrLywgXCJ3aGl0ZVwiXV0sXG4gICAgLy8gQ29tbWVudHNcbiAgICBjb21tZW50czogW1svKCMpKC4qKS8sIFtcImNvbW1lbnQucHVuY3R1YXRpb25cIiwgXCJjb21tZW50XCJdXV0sXG4gICAgLy8gS2V5d29yZCBsaXN0IHNob3J0aGFuZFxuICAgIGtleXdvcmRzU2hvcnRoYW5kOiBbXG4gICAgICBbLyhAYXRvbU5hbWUpKDopKFxccyspLywgW1wiY29uc3RhbnRcIiwgXCJjb25zdGFudC5wdW5jdHVhdGlvblwiLCBcIndoaXRlXCJdXSxcbiAgICAgIC8vIFVzZSBwb3NpdGl2ZSBsb29rLWFoZWFkIHRvIGVuc3VyZSB0aGUgc3RyaW5nIGlzIGZvbGxvd2VkIGJ5IDpcbiAgICAgIC8vIGFuZCBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGtleXdvcmQuXG4gICAgICBbXG4gICAgICAgIC9cIig/PShbXlwiXXwjXFx7Lio/XFx9fFxcXFxcIikqXCI6KS8sXG4gICAgICAgIHsgdG9rZW46IFwiY29uc3RhbnQuZGVsaW1pdGVyXCIsIG5leHQ6IFwiQGRvdWJsZVF1b3RlZFN0cmluZ0tleXdvcmRcIiB9XG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAvJyg/PShbXiddfCNcXHsuKj9cXH18XFxcXCcpKic6KS8sXG4gICAgICAgIHsgdG9rZW46IFwiY29uc3RhbnQuZGVsaW1pdGVyXCIsIG5leHQ6IFwiQHNpbmdsZVF1b3RlZFN0cmluZ0tleXdvcmRcIiB9XG4gICAgICBdXG4gICAgXSxcbiAgICBkb3VibGVRdW90ZWRTdHJpbmdLZXl3b3JkOiBbXG4gICAgICBbL1wiOi8sIHsgdG9rZW46IFwiY29uc3RhbnQuZGVsaW1pdGVyXCIsIG5leHQ6IFwiQHBvcFwiIH1dLFxuICAgICAgeyBpbmNsdWRlOiBcIkBzdHJpbmdDb25zdGFudENvbnRlbnRJbnRlcnBvbFwiIH1cbiAgICBdLFxuICAgIHNpbmdsZVF1b3RlZFN0cmluZ0tleXdvcmQ6IFtcbiAgICAgIFsvJzovLCB7IHRva2VuOiBcImNvbnN0YW50LmRlbGltaXRlclwiLCBuZXh0OiBcIkBwb3BcIiB9XSxcbiAgICAgIHsgaW5jbHVkZTogXCJAc3RyaW5nQ29uc3RhbnRDb250ZW50SW50ZXJwb2xcIiB9XG4gICAgXSxcbiAgICAvLyBOdW1iZXJzXG4gICAgbnVtYmVyczogW1xuICAgICAgWy8wYkBiaW5hcnkvLCBcIm51bWJlci5iaW5hcnlcIl0sXG4gICAgICBbLzBvQG9jdGFsLywgXCJudW1iZXIub2N0YWxcIl0sXG4gICAgICBbLzB4QGhleC8sIFwibnVtYmVyLmhleFwiXSxcbiAgICAgIFsvQGRlY2ltYWxcXC5AZGVjaW1hbChbZUVdLT9AZGVjaW1hbCk/LywgXCJudW1iZXIuZmxvYXRcIl0sXG4gICAgICBbL0BkZWNpbWFsLywgXCJudW1iZXJcIl1cbiAgICBdLFxuICAgIC8vIElkZW50aWZpZXJzXG4gICAgaWRlbnRpZmllcnM6IFtcbiAgICAgIC8vIFRva2VuaXplIGlkZW50aWZpZXIgbmFtZSBpbiBmdW5jdGlvbi1saWtlIGRlZmluaXRpb25zLlxuICAgICAgLy8gTm90ZTogZ2l2ZW4gYGRlZiBhICsgYiwgZG86IG5pbGAsIGBhYCBpcyBub3QgYSBmdW5jdGlvbiBuYW1lLFxuICAgICAgLy8gc28gd2UgdXNlIG5lZ2F0aXZlIGxvb2stYWhlYWQgdG8gZW5zdXJlIHRoZXJlJ3Mgbm8gb3BlcmF0b3IuXG4gICAgICBbXG4gICAgICAgIC9cXGIoZGVmcD98ZGVmbnA/fGRlZm1hY3JvcD98ZGVmZ3VhcmRwP3xkZWZkZWxlZ2F0ZSkoXFxzKykoQHZhcmlhYmxlTmFtZSkoPyFcXHMrQG9wZXJhdG9yKS8sXG4gICAgICAgIFtcbiAgICAgICAgICBcImtleXdvcmQuZGVjbGFyYXRpb25cIixcbiAgICAgICAgICBcIndoaXRlXCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2FzZXM6IHtcbiAgICAgICAgICAgICAgdW5xdW90ZTogXCJrZXl3b3JkXCIsXG4gICAgICAgICAgICAgIFwiQGRlZmF1bHRcIjogXCJmdW5jdGlvblwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICBdLFxuICAgICAgLy8gVG9rZW5pemUgZnVuY3Rpb24gY2FsbHNcbiAgICAgIFtcbiAgICAgICAgLy8gSW4tc2NvcGUgY2FsbCAtIGFuIGlkZW50aWZpZXIgZm9sbG93ZWQgYnkgKCBvciAuKFxuICAgICAgICAvKEB2YXJpYWJsZU5hbWUpKD89XFxzKlxcLj9cXHMqXFwoKS8sXG4gICAgICAgIHtcbiAgICAgICAgICBjYXNlczoge1xuICAgICAgICAgICAgLy8gVG9rZW5pemUgYXMga2V5d29yZCBpbiBjYXNlcyBsaWtlIGBpZiguLi4sIGRvOiAuLi4sIGVsc2U6IC4uLilgXG4gICAgICAgICAgICBcIkBkZWNsYXJhdGlvbktleXdvcmRzXCI6IFwia2V5d29yZC5kZWNsYXJhdGlvblwiLFxuICAgICAgICAgICAgXCJAbmFtZXNwYWNlS2V5d29yZHNcIjogXCJrZXl3b3JkXCIsXG4gICAgICAgICAgICBcIkBvdGhlcktleXdvcmRzXCI6IFwia2V5d29yZFwiLFxuICAgICAgICAgICAgXCJAZGVmYXVsdFwiOiBcImZ1bmN0aW9uLmNhbGxcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgLy8gUmVmZXJlbmNpbmcgZnVuY3Rpb24gaW4gYSBtb2R1bGVcbiAgICAgICAgLyhAbW9kdWxlTmFtZSkoXFxzKikoXFwuKShcXHMqKShAdmFyaWFibGVOYW1lKS8sXG4gICAgICAgIFtcInR5cGUuaWRlbnRpZmllclwiLCBcIndoaXRlXCIsIFwib3BlcmF0b3JcIiwgXCJ3aGl0ZVwiLCBcImZ1bmN0aW9uLmNhbGxcIl1cbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgIC8vIFJlZmVyZW5jaW5nIGZ1bmN0aW9uIGluIGFuIEVybGFuZyBtb2R1bGVcbiAgICAgICAgLyg6KShAYXRvbU5hbWUpKFxccyopKFxcLikoXFxzKikoQHZhcmlhYmxlTmFtZSkvLFxuICAgICAgICBbXCJjb25zdGFudC5wdW5jdHVhdGlvblwiLCBcImNvbnN0YW50XCIsIFwid2hpdGVcIiwgXCJvcGVyYXRvclwiLCBcIndoaXRlXCIsIFwiZnVuY3Rpb24uY2FsbFwiXVxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgLy8gUGlwaW5nIGludG8gYSBmdW5jdGlvbiAodG9rZW5pemVkIHNlcGFyYXRlbHkgYXMgaXQgbWF5IG5vdCBoYXZlIHBhcmVudGhlc2VzKVxuICAgICAgICAvKFxcfD4pKFxccyopKEB2YXJpYWJsZU5hbWUpLyxcbiAgICAgICAgW1xuICAgICAgICAgIFwib3BlcmF0b3JcIixcbiAgICAgICAgICBcIndoaXRlXCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2FzZXM6IHtcbiAgICAgICAgICAgICAgXCJAb3RoZXJLZXl3b3Jkc1wiOiBcImtleXdvcmRcIixcbiAgICAgICAgICAgICAgXCJAZGVmYXVsdFwiOiBcImZ1bmN0aW9uLmNhbGxcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgLy8gRnVuY3Rpb24gcmVmZXJlbmNlIHBhc3NlZCB0byBhbm90aGVyIGZ1bmN0aW9uXG4gICAgICAgIC8oJikoXFxzKikoQHZhcmlhYmxlTmFtZSkvLFxuICAgICAgICBbXCJvcGVyYXRvclwiLCBcIndoaXRlXCIsIFwiZnVuY3Rpb24uY2FsbFwiXVxuICAgICAgXSxcbiAgICAgIC8vIExhbmd1YWdlIGtleXdvcmRzLCBidWlsdGlucywgY29uc3RhbnRzIGFuZCB2YXJpYWJsZXNcbiAgICAgIFtcbiAgICAgICAgL0B2YXJpYWJsZU5hbWUvLFxuICAgICAgICB7XG4gICAgICAgICAgY2FzZXM6IHtcbiAgICAgICAgICAgIFwiQGRlY2xhcmF0aW9uS2V5d29yZHNcIjogXCJrZXl3b3JkLmRlY2xhcmF0aW9uXCIsXG4gICAgICAgICAgICBcIkBvcGVyYXRvcktleXdvcmRzXCI6IFwia2V5d29yZC5vcGVyYXRvclwiLFxuICAgICAgICAgICAgXCJAbmFtZXNwYWNlS2V5d29yZHNcIjogXCJrZXl3b3JkXCIsXG4gICAgICAgICAgICBcIkBvdGhlcktleXdvcmRzXCI6IFwia2V5d29yZFwiLFxuICAgICAgICAgICAgXCJAY29uc3RhbnRzXCI6IFwiY29uc3RhbnQubGFuZ3VhZ2VcIixcbiAgICAgICAgICAgIFwiQG5hbWVCdWlsdGluXCI6IFwidmFyaWFibGUubGFuZ3VhZ2VcIixcbiAgICAgICAgICAgIFwiXy4qXCI6IFwiY29tbWVudC51bnVzZWRcIixcbiAgICAgICAgICAgIFwiQGRlZmF1bHRcIjogXCJpZGVudGlmaWVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICAvLyBNb2R1bGUgbmFtZXNcbiAgICAgIFsvQG1vZHVsZU5hbWUvLCBcInR5cGUuaWRlbnRpZmllclwiXVxuICAgIF0sXG4gICAgLy8gU3RyaW5nc1xuICAgIHN0cmluZ3M6IFtcbiAgICAgIFsvXCJcIlwiLywgeyB0b2tlbjogXCJzdHJpbmcuZGVsaW1pdGVyXCIsIG5leHQ6IFwiQGRvdWJsZVF1b3RlZEhlcmVkb2NcIiB9XSxcbiAgICAgIFsvJycnLywgeyB0b2tlbjogXCJzdHJpbmcuZGVsaW1pdGVyXCIsIG5leHQ6IFwiQHNpbmdsZVF1b3RlZEhlcmVkb2NcIiB9XSxcbiAgICAgIFsvXCIvLCB7IHRva2VuOiBcInN0cmluZy5kZWxpbWl0ZXJcIiwgbmV4dDogXCJAZG91YmxlUXVvdGVkU3RyaW5nXCIgfV0sXG4gICAgICBbLycvLCB7IHRva2VuOiBcInN0cmluZy5kZWxpbWl0ZXJcIiwgbmV4dDogXCJAc2luZ2xlUXVvdGVkU3RyaW5nXCIgfV1cbiAgICBdLFxuICAgIGRvdWJsZVF1b3RlZEhlcmVkb2M6IFtcbiAgICAgIFsvXCJcIlwiLywgeyB0b2tlbjogXCJzdHJpbmcuZGVsaW1pdGVyXCIsIG5leHQ6IFwiQHBvcFwiIH1dLFxuICAgICAgeyBpbmNsdWRlOiBcIkBzdHJpbmdDb250ZW50SW50ZXJwb2xcIiB9XG4gICAgXSxcbiAgICBzaW5nbGVRdW90ZWRIZXJlZG9jOiBbXG4gICAgICBbLycnJy8sIHsgdG9rZW46IFwic3RyaW5nLmRlbGltaXRlclwiLCBuZXh0OiBcIkBwb3BcIiB9XSxcbiAgICAgIHsgaW5jbHVkZTogXCJAc3RyaW5nQ29udGVudEludGVycG9sXCIgfVxuICAgIF0sXG4gICAgZG91YmxlUXVvdGVkU3RyaW5nOiBbXG4gICAgICBbL1wiLywgeyB0b2tlbjogXCJzdHJpbmcuZGVsaW1pdGVyXCIsIG5leHQ6IFwiQHBvcFwiIH1dLFxuICAgICAgeyBpbmNsdWRlOiBcIkBzdHJpbmdDb250ZW50SW50ZXJwb2xcIiB9XG4gICAgXSxcbiAgICBzaW5nbGVRdW90ZWRTdHJpbmc6IFtcbiAgICAgIFsvJy8sIHsgdG9rZW46IFwic3RyaW5nLmRlbGltaXRlclwiLCBuZXh0OiBcIkBwb3BcIiB9XSxcbiAgICAgIHsgaW5jbHVkZTogXCJAc3RyaW5nQ29udGVudEludGVycG9sXCIgfVxuICAgIF0sXG4gICAgLy8gQXRvbXNcbiAgICBhdG9tczogW1xuICAgICAgWy8oOikoQGF0b21OYW1lKS8sIFtcImNvbnN0YW50LnB1bmN0dWF0aW9uXCIsIFwiY29uc3RhbnRcIl1dLFxuICAgICAgWy86XCIvLCB7IHRva2VuOiBcImNvbnN0YW50LmRlbGltaXRlclwiLCBuZXh0OiBcIkBkb3VibGVRdW90ZWRTdHJpbmdBdG9tXCIgfV0sXG4gICAgICBbLzonLywgeyB0b2tlbjogXCJjb25zdGFudC5kZWxpbWl0ZXJcIiwgbmV4dDogXCJAc2luZ2xlUXVvdGVkU3RyaW5nQXRvbVwiIH1dXG4gICAgXSxcbiAgICBkb3VibGVRdW90ZWRTdHJpbmdBdG9tOiBbXG4gICAgICBbL1wiLywgeyB0b2tlbjogXCJjb25zdGFudC5kZWxpbWl0ZXJcIiwgbmV4dDogXCJAcG9wXCIgfV0sXG4gICAgICB7IGluY2x1ZGU6IFwiQHN0cmluZ0NvbnN0YW50Q29udGVudEludGVycG9sXCIgfVxuICAgIF0sXG4gICAgc2luZ2xlUXVvdGVkU3RyaW5nQXRvbTogW1xuICAgICAgWy8nLywgeyB0b2tlbjogXCJjb25zdGFudC5kZWxpbWl0ZXJcIiwgbmV4dDogXCJAcG9wXCIgfV0sXG4gICAgICB7IGluY2x1ZGU6IFwiQHN0cmluZ0NvbnN0YW50Q29udGVudEludGVycG9sXCIgfVxuICAgIF0sXG4gICAgLy8gU2lnaWxzXG4gICAgLy8gU2VlIGh0dHBzOi8vZWxpeGlyLWxhbmcub3JnL2dldHRpbmctc3RhcnRlZC9zaWdpbHMuaHRtbFxuICAgIC8vIFNpZ2lscyBhbGxvdyBmb3IgdHlwaW5nIHZhbHVlcyB1c2luZyB0aGVpciB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uLlxuICAgIC8vIEFsbCBzaWdpbHMgc3RhcnQgd2l0aCB+IGZvbGxvd2VkIGJ5IGEgbGV0dGVyIG9yXG4gICAgLy8gbXVsdGktbGV0dGVyIHVwcGVyY2FzZSBzdGFydGluZyBhdCBFbGl4aXIgdjEuMTUuMCwgaW5kaWNhdGluZyBzaWdpbCB0eXBlXG4gICAgLy8gYW5kIHRoZW4gYSBkZWxpbWl0ZXIgcGFpciBlbmNsb3NpbmcgdGhlIHRleHR1YWwgcmVwcmVzZW50YXRpb24uXG4gICAgLy8gT3B0aW9uYWwgbW9kaWZpZXJzIGFyZSBhbGxvd2VkIGFmdGVyIHRoZSBjbG9zaW5nIGRlbGltaXRlci5cbiAgICAvLyBGb3IgaW5zdGFuY2UgYSByZWd1bGFyIGV4cHJlc3Npb25zIGNhbiBiZSB3cml0dGVuIGFzOlxuICAgIC8vIH5yL2Zvb3xiYXIvIH5ye2Zvb3xiYXJ9IH5yL2Zvb3xiYXIvZ1xuICAgIC8vXG4gICAgLy8gSW4gZ2VuZXJhbCBsb3dlcmNhc2Ugc2lnaWxzIGFsbG93IGZvciBpbnRlcnBvbGF0aW9uXG4gICAgLy8gYW5kIGVzY2FwZWQgY2hhcmFjdGVycywgd2hlcmVhcyB1cHBlcmNhc2Ugc2lnaWxzIGRvbid0XG4gICAgLy9cbiAgICAvLyBEdXJpbmcgdG9rZW5pemF0aW9uIHdlIHdhbnQgdG8gZGlzdGluZ3Vpc2ggc29tZVxuICAgIC8vIHNwZWNpZmljIHNpZ2lsIHR5cGVzLCBuYW1lbHkgc3RyaW5nIGFuZCByZWdleHAsXG4gICAgLy8gc28gdGhhdCB0aGV5IGNlbiBiZSB0aGVtZWQgc2VwYXJhdGVseS5cbiAgICAvL1xuICAgIC8vIFRvIHJlYXNvbmFibHkgaGFuZGxlIGFsbCB0aG9zZSBjb21iaW5hdGlvbnMgd2UgbGV2ZXJhZ2VcbiAgICAvLyBkb3Qtc2VwYXJhdGVkIHN0YXRlcywgc28gaWYgd2UgdHJhbnNpdGlvbiB0byBAc2lnaWxTdGFydC5pbnRlcnBvbC5zLnsufVxuICAgIC8vIHRoZW4gXCJzaWdpbFN0YXJ0LmludGVycG9sLnNcIiBzdGF0ZSB3aWxsIG1hdGNoIGFuZCBhbHNvIGFsbFxuICAgIC8vIHRoZSBpbmRpdmlkdWFsIGRvdC1zZXBhcmF0ZWQgcGFyYW1ldGVycyBjYW4gYmUgYWNjZXNzZWQuXG4gICAgc2lnaWxzOiBbXG4gICAgICBbL35bYS16XUBzaWdpbFN0YXJ0RGVsaW1pdGVyLywgeyB0b2tlbjogXCJAcmVtYXRjaFwiLCBuZXh0OiBcIkBzaWdpbC5pbnRlcnBvbFwiIH1dLFxuICAgICAgWy9+KFtBLVpdKylAc2lnaWxTdGFydERlbGltaXRlci8sIHsgdG9rZW46IFwiQHJlbWF0Y2hcIiwgbmV4dDogXCJAc2lnaWwubm9JbnRlcnBvbFwiIH1dXG4gICAgXSxcbiAgICBzaWdpbDogW1xuICAgICAgWy9+KFthLXpdfFtBLVpdKylcXHsvLCB7IHRva2VuOiBcIkByZW1hdGNoXCIsIHN3aXRjaFRvOiBcIkBzaWdpbFN0YXJ0LiRTMi4kMS57Ln1cIiB9XSxcbiAgICAgIFsvfihbYS16XXxbQS1aXSspXFxbLywgeyB0b2tlbjogXCJAcmVtYXRjaFwiLCBzd2l0Y2hUbzogXCJAc2lnaWxTdGFydC4kUzIuJDEuWy5dXCIgfV0sXG4gICAgICBbL34oW2Etel18W0EtWl0rKVxcKC8sIHsgdG9rZW46IFwiQHJlbWF0Y2hcIiwgc3dpdGNoVG86IFwiQHNpZ2lsU3RhcnQuJFMyLiQxLiguKVwiIH1dLFxuICAgICAgWy9+KFthLXpdfFtBLVpdKylcXDwvLCB7IHRva2VuOiBcIkByZW1hdGNoXCIsIHN3aXRjaFRvOiBcIkBzaWdpbFN0YXJ0LiRTMi4kMS48Lj5cIiB9XSxcbiAgICAgIFtcbiAgICAgICAgL34oW2Etel18W0EtWl0rKShAc2lnaWxTeW1tZXRyaWNEZWxpbWl0ZXIpLyxcbiAgICAgICAgeyB0b2tlbjogXCJAcmVtYXRjaFwiLCBzd2l0Y2hUbzogXCJAc2lnaWxTdGFydC4kUzIuJDEuJDIuJDJcIiB9XG4gICAgICBdXG4gICAgXSxcbiAgICAvLyBUaGUgZGVmaW5pdGlvbnMgYmVsb3cgZXhwZWN0IHN0YXRlcyB0byBiZSBvZiB0aGUgZm9ybTpcbiAgICAvL1xuICAgIC8vIHNpZ2lsU3RhcnQuPGludGVycG9sLW9yLW5vSW50ZXJwb2w+LjxzaWdpbC1sZXR0ZXI+LjxzdGFydC1kZWxpbWl0ZXI+LjxlbmQtZGVsaW1pdGVyPlxuICAgIC8vIHNpZ2lsQ29udGludWUuPGludGVycG9sLW9yLW5vSW50ZXJwb2w+LjxzaWdpbC1sZXR0ZXI+LjxzdGFydC1kZWxpbWl0ZXI+LjxlbmQtZGVsaW1pdGVyPlxuICAgIC8vXG4gICAgLy8gVGhlIHNpZ2lsU3RhcnQgc3RhdGUgaXMgdXNlZCBvbmx5IHRvIHByb3Blcmx5IGNsYXNzaWZ5IHRoZSB0b2tlbiAoYXMgc3RyaW5nL3JlZ2V4L3NpZ2lsKVxuICAgIC8vIGFuZCBpbW1lZGlhdGVseSBzd2l0Y2hlcyB0byB0aGUgc2lnaWxDb250aW51ZSBzYXRlLCB3aGljaCBoYW5kbGVzIHRoZSBhY3R1YWwgY29udGVudFxuICAgIC8vIGFuZCB3YWl0cyBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgZW5kIGRlbGltaXRlci5cbiAgICBcInNpZ2lsU3RhcnQuaW50ZXJwb2wuc1wiOiBbXG4gICAgICBbXG4gICAgICAgIC9+c0BzaWdpbFN0YXJ0RGVsaW1pdGVyLyxcbiAgICAgICAge1xuICAgICAgICAgIHRva2VuOiBcInN0cmluZy5kZWxpbWl0ZXJcIixcbiAgICAgICAgICBzd2l0Y2hUbzogXCJAc2lnaWxDb250aW51ZS4kUzIuJFMzLiRTNC4kUzVcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgXSxcbiAgICBcInNpZ2lsQ29udGludWUuaW50ZXJwb2wuc1wiOiBbXG4gICAgICBbXG4gICAgICAgIC8oQHNpZ2lsRW5kRGVsaW1pdGVyKUBzaWdpbE1vZGlmaWVycy8sXG4gICAgICAgIHtcbiAgICAgICAgICBjYXNlczoge1xuICAgICAgICAgICAgXCIkMT09JFM1XCI6IHsgdG9rZW46IFwic3RyaW5nLmRlbGltaXRlclwiLCBuZXh0OiBcIkBwb3BcIiB9LFxuICAgICAgICAgICAgXCJAZGVmYXVsdFwiOiBcInN0cmluZ1wiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgeyBpbmNsdWRlOiBcIkBzdHJpbmdDb250ZW50SW50ZXJwb2xcIiB9XG4gICAgXSxcbiAgICBcInNpZ2lsU3RhcnQubm9JbnRlcnBvbC5TXCI6IFtcbiAgICAgIFtcbiAgICAgICAgL35TQHNpZ2lsU3RhcnREZWxpbWl0ZXIvLFxuICAgICAgICB7XG4gICAgICAgICAgdG9rZW46IFwic3RyaW5nLmRlbGltaXRlclwiLFxuICAgICAgICAgIHN3aXRjaFRvOiBcIkBzaWdpbENvbnRpbnVlLiRTMi4kUzMuJFM0LiRTNVwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICBdLFxuICAgIFwic2lnaWxDb250aW51ZS5ub0ludGVycG9sLlNcIjogW1xuICAgICAgLy8gSWdub3JlIGVzY2FwZWQgc2lnaWwgZW5kXG4gICAgICBbLyhefFteXFxcXF0pXFxcXEBzaWdpbEVuZERlbGltaXRlci8sIFwic3RyaW5nXCJdLFxuICAgICAgW1xuICAgICAgICAvKEBzaWdpbEVuZERlbGltaXRlcilAc2lnaWxNb2RpZmllcnMvLFxuICAgICAgICB7XG4gICAgICAgICAgY2FzZXM6IHtcbiAgICAgICAgICAgIFwiJDE9PSRTNVwiOiB7IHRva2VuOiBcInN0cmluZy5kZWxpbWl0ZXJcIiwgbmV4dDogXCJAcG9wXCIgfSxcbiAgICAgICAgICAgIFwiQGRlZmF1bHRcIjogXCJzdHJpbmdcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIHsgaW5jbHVkZTogXCJAc3RyaW5nQ29udGVudFwiIH1cbiAgICBdLFxuICAgIFwic2lnaWxTdGFydC5pbnRlcnBvbC5yXCI6IFtcbiAgICAgIFtcbiAgICAgICAgL35yQHNpZ2lsU3RhcnREZWxpbWl0ZXIvLFxuICAgICAgICB7XG4gICAgICAgICAgdG9rZW46IFwicmVnZXhwLmRlbGltaXRlclwiLFxuICAgICAgICAgIHN3aXRjaFRvOiBcIkBzaWdpbENvbnRpbnVlLiRTMi4kUzMuJFM0LiRTNVwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICBdLFxuICAgIFwic2lnaWxDb250aW51ZS5pbnRlcnBvbC5yXCI6IFtcbiAgICAgIFtcbiAgICAgICAgLyhAc2lnaWxFbmREZWxpbWl0ZXIpQHNpZ2lsTW9kaWZpZXJzLyxcbiAgICAgICAge1xuICAgICAgICAgIGNhc2VzOiB7XG4gICAgICAgICAgICBcIiQxPT0kUzVcIjogeyB0b2tlbjogXCJyZWdleHAuZGVsaW1pdGVyXCIsIG5leHQ6IFwiQHBvcFwiIH0sXG4gICAgICAgICAgICBcIkBkZWZhdWx0XCI6IFwicmVnZXhwXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICB7IGluY2x1ZGU6IFwiQHJlZ2V4cENvbnRlbnRJbnRlcnBvbFwiIH1cbiAgICBdLFxuICAgIFwic2lnaWxTdGFydC5ub0ludGVycG9sLlJcIjogW1xuICAgICAgW1xuICAgICAgICAvflJAc2lnaWxTdGFydERlbGltaXRlci8sXG4gICAgICAgIHtcbiAgICAgICAgICB0b2tlbjogXCJyZWdleHAuZGVsaW1pdGVyXCIsXG4gICAgICAgICAgc3dpdGNoVG86IFwiQHNpZ2lsQ29udGludWUuJFMyLiRTMy4kUzQuJFM1XCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIF0sXG4gICAgXCJzaWdpbENvbnRpbnVlLm5vSW50ZXJwb2wuUlwiOiBbXG4gICAgICAvLyBJZ25vcmUgZXNjYXBlZCBzaWdpbCBlbmRcbiAgICAgIFsvKF58W15cXFxcXSlcXFxcQHNpZ2lsRW5kRGVsaW1pdGVyLywgXCJyZWdleHBcIl0sXG4gICAgICBbXG4gICAgICAgIC8oQHNpZ2lsRW5kRGVsaW1pdGVyKUBzaWdpbE1vZGlmaWVycy8sXG4gICAgICAgIHtcbiAgICAgICAgICBjYXNlczoge1xuICAgICAgICAgICAgXCIkMT09JFM1XCI6IHsgdG9rZW46IFwicmVnZXhwLmRlbGltaXRlclwiLCBuZXh0OiBcIkBwb3BcIiB9LFxuICAgICAgICAgICAgXCJAZGVmYXVsdFwiOiBcInJlZ2V4cFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgeyBpbmNsdWRlOiBcIkByZWdleHBDb250ZW50XCIgfVxuICAgIF0sXG4gICAgLy8gRmFsbGJhY2sgdG8gdGhlIGdlbmVyaWMgc2lnaWwgYnkgZGVmYXVsdFxuICAgIFwic2lnaWxTdGFydC5pbnRlcnBvbFwiOiBbXG4gICAgICBbXG4gICAgICAgIC9+KFthLXpdfFtBLVpdKylAc2lnaWxTdGFydERlbGltaXRlci8sXG4gICAgICAgIHtcbiAgICAgICAgICB0b2tlbjogXCJzaWdpbC5kZWxpbWl0ZXJcIixcbiAgICAgICAgICBzd2l0Y2hUbzogXCJAc2lnaWxDb250aW51ZS4kUzIuJFMzLiRTNC4kUzVcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgXSxcbiAgICBcInNpZ2lsQ29udGludWUuaW50ZXJwb2xcIjogW1xuICAgICAgW1xuICAgICAgICAvKEBzaWdpbEVuZERlbGltaXRlcilAc2lnaWxNb2RpZmllcnMvLFxuICAgICAgICB7XG4gICAgICAgICAgY2FzZXM6IHtcbiAgICAgICAgICAgIFwiJDE9PSRTNVwiOiB7IHRva2VuOiBcInNpZ2lsLmRlbGltaXRlclwiLCBuZXh0OiBcIkBwb3BcIiB9LFxuICAgICAgICAgICAgXCJAZGVmYXVsdFwiOiBcInNpZ2lsXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICB7IGluY2x1ZGU6IFwiQHNpZ2lsQ29udGVudEludGVycG9sXCIgfVxuICAgIF0sXG4gICAgXCJzaWdpbFN0YXJ0Lm5vSW50ZXJwb2xcIjogW1xuICAgICAgW1xuICAgICAgICAvfihbYS16XXxbQS1aXSspQHNpZ2lsU3RhcnREZWxpbWl0ZXIvLFxuICAgICAgICB7XG4gICAgICAgICAgdG9rZW46IFwic2lnaWwuZGVsaW1pdGVyXCIsXG4gICAgICAgICAgc3dpdGNoVG86IFwiQHNpZ2lsQ29udGludWUuJFMyLiRTMy4kUzQuJFM1XCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIF0sXG4gICAgXCJzaWdpbENvbnRpbnVlLm5vSW50ZXJwb2xcIjogW1xuICAgICAgLy8gSWdub3JlIGVzY2FwZWQgc2lnaWwgZW5kXG4gICAgICBbLyhefFteXFxcXF0pXFxcXEBzaWdpbEVuZERlbGltaXRlci8sIFwic2lnaWxcIl0sXG4gICAgICBbXG4gICAgICAgIC8oQHNpZ2lsRW5kRGVsaW1pdGVyKUBzaWdpbE1vZGlmaWVycy8sXG4gICAgICAgIHtcbiAgICAgICAgICBjYXNlczoge1xuICAgICAgICAgICAgXCIkMT09JFM1XCI6IHsgdG9rZW46IFwic2lnaWwuZGVsaW1pdGVyXCIsIG5leHQ6IFwiQHBvcFwiIH0sXG4gICAgICAgICAgICBcIkBkZWZhdWx0XCI6IFwic2lnaWxcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIHsgaW5jbHVkZTogXCJAc2lnaWxDb250ZW50XCIgfVxuICAgIF0sXG4gICAgLy8gQXR0cmlidXRlc1xuICAgIGF0dHJpYnV0ZXM6IFtcbiAgICAgIC8vIE1vZHVsZSBAZG9jKiBhdHRyaWJ1dGVzIC0gdG9rZW5pemVkIGFzIGNvbW1lbnRzXG4gICAgICBbXG4gICAgICAgIC9cXEAobW9kdWxlfHR5cGUpP2RvYyAofltzU10pP1wiXCJcIi8sXG4gICAgICAgIHtcbiAgICAgICAgICB0b2tlbjogXCJjb21tZW50LmJsb2NrLmRvY3VtZW50YXRpb25cIixcbiAgICAgICAgICBuZXh0OiBcIkBkb3VibGVRdW90ZWRIZXJlZG9jRG9jc3RyaW5nXCJcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgL1xcQChtb2R1bGV8dHlwZSk/ZG9jICh+W3NTXSk/JycnLyxcbiAgICAgICAge1xuICAgICAgICAgIHRva2VuOiBcImNvbW1lbnQuYmxvY2suZG9jdW1lbnRhdGlvblwiLFxuICAgICAgICAgIG5leHQ6IFwiQHNpbmdsZVF1b3RlZEhlcmVkb2NEb2NzdHJpbmdcIlxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAvXFxAKG1vZHVsZXx0eXBlKT9kb2MgKH5bc1NdKT9cIi8sXG4gICAgICAgIHtcbiAgICAgICAgICB0b2tlbjogXCJjb21tZW50LmJsb2NrLmRvY3VtZW50YXRpb25cIixcbiAgICAgICAgICBuZXh0OiBcIkBkb3VibGVRdW90ZWRTdHJpbmdEb2NzdHJpbmdcIlxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAvXFxAKG1vZHVsZXx0eXBlKT9kb2MgKH5bc1NdKT8nLyxcbiAgICAgICAge1xuICAgICAgICAgIHRva2VuOiBcImNvbW1lbnQuYmxvY2suZG9jdW1lbnRhdGlvblwiLFxuICAgICAgICAgIG5leHQ6IFwiQHNpbmdsZVF1b3RlZFN0cmluZ0RvY3N0cmluZ1wiXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBbL1xcQChtb2R1bGV8dHlwZSk/ZG9jIGZhbHNlLywgXCJjb21tZW50LmJsb2NrLmRvY3VtZW50YXRpb25cIl0sXG4gICAgICAvLyBNb2R1bGUgYXR0cmlidXRlc1xuICAgICAgWy9cXEAoQHZhcmlhYmxlTmFtZSkvLCBcInZhcmlhYmxlXCJdXG4gICAgXSxcbiAgICBkb3VibGVRdW90ZWRIZXJlZG9jRG9jc3RyaW5nOiBbXG4gICAgICBbL1wiXCJcIi8sIHsgdG9rZW46IFwiY29tbWVudC5ibG9jay5kb2N1bWVudGF0aW9uXCIsIG5leHQ6IFwiQHBvcFwiIH1dLFxuICAgICAgeyBpbmNsdWRlOiBcIkBkb2NzdHJpbmdDb250ZW50XCIgfVxuICAgIF0sXG4gICAgc2luZ2xlUXVvdGVkSGVyZWRvY0RvY3N0cmluZzogW1xuICAgICAgWy8nJycvLCB7IHRva2VuOiBcImNvbW1lbnQuYmxvY2suZG9jdW1lbnRhdGlvblwiLCBuZXh0OiBcIkBwb3BcIiB9XSxcbiAgICAgIHsgaW5jbHVkZTogXCJAZG9jc3RyaW5nQ29udGVudFwiIH1cbiAgICBdLFxuICAgIGRvdWJsZVF1b3RlZFN0cmluZ0RvY3N0cmluZzogW1xuICAgICAgWy9cIi8sIHsgdG9rZW46IFwiY29tbWVudC5ibG9jay5kb2N1bWVudGF0aW9uXCIsIG5leHQ6IFwiQHBvcFwiIH1dLFxuICAgICAgeyBpbmNsdWRlOiBcIkBkb2NzdHJpbmdDb250ZW50XCIgfVxuICAgIF0sXG4gICAgc2luZ2xlUXVvdGVkU3RyaW5nRG9jc3RyaW5nOiBbXG4gICAgICBbLycvLCB7IHRva2VuOiBcImNvbW1lbnQuYmxvY2suZG9jdW1lbnRhdGlvblwiLCBuZXh0OiBcIkBwb3BcIiB9XSxcbiAgICAgIHsgaW5jbHVkZTogXCJAZG9jc3RyaW5nQ29udGVudFwiIH1cbiAgICBdLFxuICAgIC8vIE9wZXJhdG9ycywgcHVuY3R1YXRpb24sIGJyYWNrZXRzXG4gICAgc3ltYm9sczogW1xuICAgICAgLy8gQ29kZSBwb2ludCBvcGVyYXRvciAoZWl0aGVyIHdpdGggcmVndWxhciBjaGFyYWN0ZXIgP2Egb3IgYW4gZXNjYXBlZCBvbmUgP1xcbilcbiAgICAgIFsvXFw/KFxcXFwufFteXFxcXFxcc10pLywgXCJudW1iZXIuY29uc3RhbnRcIl0sXG4gICAgICAvLyBBbm9ueW1vdXMgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICBbLyZcXGQrLywgXCJvcGVyYXRvclwiXSxcbiAgICAgIC8vIEJpdHNoaWZ0IG9wZXJhdG9ycyAobXVzdCBnbyBiZWZvcmUgZGVsaW1pdGVycywgc28gdGhhdCA8PCA+PiBkb24ndCBtYXRjaCBmaXJzdClcbiAgICAgIFsvPDw8fD4+Pi8sIFwib3BlcmF0b3JcIl0sXG4gICAgICAvLyBEZWxpbWl0ZXIgcGFpcnNcbiAgICAgIFsvWygpXFxbXFxdXFx7XFx9XXw8PHw+Pi8sIFwiQGJyYWNrZXRzXCJdLFxuICAgICAgLy8gVHJpcGxlIGRvdCBpcyBhIHZhbGlkIG5hbWUgKG11c3QgZ28gYmVmb3JlIG9wZXJhdG9ycywgc28gdGhhdCAuLiBkb2Vzbid0IG1hdGNoIGluc3RlYWQpXG4gICAgICBbL1xcLlxcLlxcLi8sIFwiaWRlbnRpZmllclwiXSxcbiAgICAgIC8vIFB1bmN0dWF0aW9uID0+IChtdXN0IGdvIGJlZm9yZSBvcGVyYXRvcnMsIHNvIGl0J3Mgbm90IHRva2VuaXplZCBhcyA9IHRoZW4gPilcbiAgICAgIFsvPT4vLCBcInB1bmN0dWF0aW9uXCJdLFxuICAgICAgLy8gT3BlcmF0b3JzXG4gICAgICBbL0BvcGVyYXRvci8sIFwib3BlcmF0b3JcIl0sXG4gICAgICAvLyBQdW5jdHVhdGlvblxuICAgICAgWy9bOjssLiVdLywgXCJwdW5jdHVhdGlvblwiXVxuICAgIF0sXG4gICAgLy8gR2VuZXJpYyBoZWxwZXJzXG4gICAgc3RyaW5nQ29udGVudEludGVycG9sOiBbXG4gICAgICB7IGluY2x1ZGU6IFwiQGludGVycG9sYXRpb25cIiB9LFxuICAgICAgeyBpbmNsdWRlOiBcIkBlc2NhcGVDaGFyXCIgfSxcbiAgICAgIHsgaW5jbHVkZTogXCJAc3RyaW5nQ29udGVudFwiIH1cbiAgICBdLFxuICAgIHN0cmluZ0NvbnRlbnQ6IFtbLy4vLCBcInN0cmluZ1wiXV0sXG4gICAgc3RyaW5nQ29uc3RhbnRDb250ZW50SW50ZXJwb2w6IFtcbiAgICAgIHsgaW5jbHVkZTogXCJAaW50ZXJwb2xhdGlvblwiIH0sXG4gICAgICB7IGluY2x1ZGU6IFwiQGVzY2FwZUNoYXJcIiB9LFxuICAgICAgeyBpbmNsdWRlOiBcIkBzdHJpbmdDb25zdGFudENvbnRlbnRcIiB9XG4gICAgXSxcbiAgICBzdHJpbmdDb25zdGFudENvbnRlbnQ6IFtbLy4vLCBcImNvbnN0YW50XCJdXSxcbiAgICByZWdleHBDb250ZW50SW50ZXJwb2w6IFtcbiAgICAgIHsgaW5jbHVkZTogXCJAaW50ZXJwb2xhdGlvblwiIH0sXG4gICAgICB7IGluY2x1ZGU6IFwiQGVzY2FwZUNoYXJcIiB9LFxuICAgICAgeyBpbmNsdWRlOiBcIkByZWdleHBDb250ZW50XCIgfVxuICAgIF0sXG4gICAgcmVnZXhwQ29udGVudDogW1xuICAgICAgLy8gIyBtYXkgYmUgYSByZWd1bGFyIHJlZ2V4cCBjaGFyLCBzbyB3ZSB1c2UgYSBoZXVyaXN0aWNcbiAgICAgIC8vIGFzc3VtaW5nIGEgIyBzdXJyb3VuZGVkIGJ5IHdoaXRlc3BhY2UgaXMgYWN0dWFsbHkgYSBjb21tZW50LlxuICAgICAgWy8oXFxzKSgjKShcXHMuKikkLywgW1wid2hpdGVcIiwgXCJjb21tZW50LnB1bmN0dWF0aW9uXCIsIFwiY29tbWVudFwiXV0sXG4gICAgICBbLy4vLCBcInJlZ2V4cFwiXVxuICAgIF0sXG4gICAgc2lnaWxDb250ZW50SW50ZXJwb2w6IFtcbiAgICAgIHsgaW5jbHVkZTogXCJAaW50ZXJwb2xhdGlvblwiIH0sXG4gICAgICB7IGluY2x1ZGU6IFwiQGVzY2FwZUNoYXJcIiB9LFxuICAgICAgeyBpbmNsdWRlOiBcIkBzaWdpbENvbnRlbnRcIiB9XG4gICAgXSxcbiAgICBzaWdpbENvbnRlbnQ6IFtbLy4vLCBcInNpZ2lsXCJdXSxcbiAgICBkb2NzdHJpbmdDb250ZW50OiBbWy8uLywgXCJjb21tZW50LmJsb2NrLmRvY3VtZW50YXRpb25cIl1dLFxuICAgIGVzY2FwZUNoYXI6IFtbL0Blc2NhcGUvLCBcImNvbnN0YW50LmNoYXJhY3Rlci5lc2NhcGVcIl1dLFxuICAgIGludGVycG9sYXRpb246IFtbLyN7LywgeyB0b2tlbjogXCJkZWxpbWl0ZXIuYnJhY2tldC5lbWJlZFwiLCBuZXh0OiBcIkBpbnRlcnBvbGF0aW9uQ29udGludWVcIiB9XV0sXG4gICAgaW50ZXJwb2xhdGlvbkNvbnRpbnVlOiBbXG4gICAgICBbL30vLCB7IHRva2VuOiBcImRlbGltaXRlci5icmFja2V0LmVtYmVkXCIsIG5leHQ6IFwiQHBvcFwiIH1dLFxuICAgICAgLy8gSW50ZXJwb2xhdGlvbiBicmFja2V0cyBtYXkgY29udGFpbiBhcmJpdHJhcnkgY29kZSxcbiAgICAgIC8vIHNvIHdlIHNpbXBseSBtYXRjaCBhZ2FpbnN0IGFsbCB0aGUgcm9vdCBydWxlcyxcbiAgICAgIC8vIHVudGlsIHdlIHJlYWNoIGludGVycG9sYXRpb24gZW5kICh0aGUgYWJvdmUgbWF0Y2hlcykuXG4gICAgICB7IGluY2x1ZGU6IFwiQHJvb3RcIiB9XG4gICAgXVxuICB9XG59O1xuZXhwb3J0IHtcbiAgY29uZixcbiAgbGFuZ3VhZ2Vcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/@camunda/rpa-integration/node_modules/monaco-editor/esm/vs/basic-languages/elixir/elixir.js\n\n}");

/***/ }

}]);